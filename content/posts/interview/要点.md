---
title: '面试中可能遇到的一些问题的要点提纲'
date: 2024-06-14T21:59:29+08:00
# weight: 1
# aliases: ["/alias"]
tags: ["面试"]
author: "sweetpear"
# author: ["Me", "You"] # multiple authors
showToc: true
TocOpen: false
draft: false
hidemeta: false
comments: false
description: ""
summary: "面试八股文的一些要点提纲。"
# canonicalURL: "https://canonical.url/to/page"
---
# Go
## map
### 哈希冲突解决方法
开放寻址、拉链

### 桶数组 旧桶数组 溢出桶 旧溢出桶
* 为什么有旧桶数组：扩容不是原子过程 扩容过程中读取数据可能需要旧桶
* 什么时候使用溢出桶：正常桶中8个位置用完了
* 一个正常桶的溢出桶们类似链表形式穿起来，正常桶为头结点，两种桶只是概念区分，数据结构相同
* 桶结构中tophash数组作用：存储key哈希值高八位快速定位，比遍历桶效率高，类似索引但只做定位不保证一定是对应的key

### 通过key找value
1. 计算key值哈希 
2. 低B位确定桶序号 （低B高8保证tophash的值不会大量重复）
3. 高8位通过tophash数组快速定位键在桶中位置（只是高8位相同，不代表键值一定相同）
4. 比较键值（遍历正常桶溢出桶直到找到）

### 扩容
写入过程中触发
* 翻倍扩容：装载因子已经超过6.5（平均一个桶装超过6.5个元素）
* 等量扩容： 哈希使用了太多溢出桶（元素添加又删除）

## GMP模型
### 进程线程协程
区别：创建销毁、切换成本、内存占用

### 调度器
全局变量 保存空闲m、p、全局队列、全局deadG缓存等 

发生调度时可能会从调度器中获取想要的东西

### g0
每个m上都有属于自己的g0，g0负责执行调度函数（寻找待执行g，执行期间挂起，结束后切换回g0继续调度，调度函数无限循环）

g0还负责创建新的g

### p有什么用
减少全局队列调用频率（取全局要加锁）

### 状态
g 三状态/五状态 m 两状态 p  五状态

### 触发调度的五个条件
1. 系统调用
2. 当前g执行完成或m初始化之后
3. GC或系统监控
4. 同步阻塞
5. 协作式调度，主动让出p

### 调度函数的执行逻辑
1. 每61次从全局队列取一个g
2. 从p本地队列取
3. 从全局队列取 数量在: 每个p可以平分到的全局队列g数量 ~ 本队队列容量一半
4. netpoll
5. 偷其他p （尝试四次，前三次偷对方本地队列的一半，最后不行偷一个runnext）
6. 实在没有了就休眠当前m

## 内存分配
多级缓存+隔离适应分配策略

### 分配器
两种：线性分配器 、 空闲链表分配器（四种分配策略）

### 核心组件
mspan go内存管理基本单元 管理着几个内存页，对应一种大小的跨度类，为大小属于这个跨度类的对象分配内存（隔离适应策略）
 * go页和系统页
mcache mcentral mheap

### 分配对象
微对象且非指针：在mcache上tiny mspan管理的内存块中挤一挤
指针类型微对象+小对象：三级依次尝试
大对象：直接在堆上分配

## 垃圾收集
### 垃圾收集算法
追踪式 标记清除、分代式、三色标记清除
引用计数式 python

### 收集策略
增量+并发

三色不变形+屏障技术保证回收正确性（不会出现悬挂指针）

三色：白（未扫描），灰（已扫但指向未扫对象），黑（已扫）

强弱三色不变性

* 插入写屏障（在修改引用时，将新指向的对象置灰）：强三色，可能遗留不再存活对象，栈对象也得加
* 删除写屏障（在删除引用时，如果原来指向的对象为白色，则将其置灰）：弱三色，也可能遗留不再存活对象
** 两种屏障都存在的问题：对栈对象加屏障严重拖累性能，尤其对于go来说（goroutine可以很多）
* 因此使用混合写屏障

### 触发GC
阈值：增长100%堆内存 环境变量GOGC （实际上不到100%就要开始GC了）

三时机：后台，手动，内存分配

### GC
四阶段：清理终止阶段 –> 标记阶段 –> 标记终止阶段–> 清理阶段

后台标记模式：为每个P创建一个用于标记的G(休眠状态等待调度器唤醒)；通过并发加快标记速度

辅助标记：当前 goroutine 分配内存时，通过控制分配与标记的“动态平衡”，保证到达触发阈值时完成标记任务；

观察GC四个办法 命令行GODEBUG 代码内trace、debug.ReadGCStats、runtime.ReadMemStats

GC调优四方法：控制内存申请速度、少申请内存、复用已申请内存、减少GC频率

## init
同一包：同一文件内、不同文件间
不同包：有依赖关系、无依赖

包内：常量 > 变量 > init

整体：从依赖最底层的包逐层向上初始化

## IO
两阶段：等待数据准备、在内核和用户程序间拷贝数据
        阻塞/非阻塞       同步/异步

BIO NIO AIO SIGIO 多路复用

多路复用 VS NIO （区别：轮询资源就绪是否是亲力亲为  共同点：同步IO）

select poll VS epoll （内存开销，时间复杂度）

### netpoll
基于多路复用+NIO go原生net包tcp server的底层实现

netpoll的价值：避免系统调用阻塞M

#### 为什么说 netpoll 是 NIO + 多路复用？
NIO指的是对于线程 M，发生I/O操作时不会因为系统调用而被阻塞

多路复用指的是操作系统层面，使用提供的 epoll、kqueue等多路复用技术

#### netpoll优势
保证了在I/O密集型服务中，go依旧可以实现在运行中进行用户级调度，提高了并发能力，减少了系统资源占用

#### netpoll存在的问题
服务器在短时间内建立了海量连接，会导致创建大量的goroutine，过多的消耗系统资源。

解决办法：连接池、限流器、请求队列（Reactor模型就用了连接池）


## channel
环形数组（有缓冲区）+ 接收阻塞队列 + 发送阻塞队列 + lock（并发控制）

堆上分配

向channel发送：三特判、三种情况（直接取接收阻塞队头/放到缓冲区/挂起G放入发送阻塞队列）
* 三种情况：阻塞队列不为空、缓冲区不为空、都为空
从channel接收：三特判、三种情况（取缓冲区并递补发送队列队头/取缓冲区/挂起G放入接收队列）

### nil channel作用
select中禁用当前case
### 资源泄露隐患
等待队列任务得不到释放
### 应用
异步通信（超时控制、解耦生产消费方） 缓冲区（限制并发数）

## select关键字
同时监听多个 channel 状态

顺序加锁：防止多个select并发加锁导致死锁

随机轮询所有case防止饥饿

# Git
## 合并
### merge 
快速合并 三路合并
git merge [ -ff | --no-ff | --ff-only ] <branch> [<target>]
### rebase 
git rebase [-i] [--onto <newbase> | --keep-base] [<upstream> [<branch>]]
### cherrypick
git cherry-pick A..B

# Redis 
五种基本类型+四种拓展类型

## 八种底层数据结构
SDS 与C原生string相比优势
ziplist 7.0之后弃用 紧凑布局保存int或string
listpack 5.0之后启用
quicklist 双向链表+压缩链表
哈希表 桶数组+拉链法
整数集 升序
skiplist 跳表，多级有序链表
radix树 

## 持久化
### aof
保存写命令
三种写回策略
aof重写 fork子进程 主进程重写缓冲区

### rdb
全量快照、增量快照、混合快照

### 主从复制
全量复制、基于长连接的命令传播、增量复制

主从一致性问题：replication buffer 缓冲区（全量），repl_backlog_buffer环形缓冲区（增量）

### 分布式锁
lock for循环尝试20次，setnx
unlock lua 如果key==value则del键，否则return 0


# PG
## 隔离级别
读未提交：pg中与读已提交一致
读已提交：解决脏读，只会读到其他事务已提交的数据 针对select
可重复度：解决不可重复读，当前事务执行期间不允许其他事务对数据进行修改 针对update
串行化：解决幻读，事务顺序执行 针对insert

## 主从同步
流复制（WAL预写日志） 逻辑复制（可以指定表）