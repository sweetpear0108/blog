<!doctype html><html lang=en dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Go 内存分配器 | Sweetpear's Blog</title>
<meta name=keywords content="golang,内存分配器"><meta name=description content="介绍了go内存分配的三级模型，还讨论了分配器的种类和设计原则，以及内存布局的组件和对象分配的流程。整体而言，Go的内存分配器通过多级缓存和分级分配的思想，提高了内存管理的效率和空间利用率。"><meta name=author content="sweetpear"><link rel=canonical href=http://localhost:1313/posts/golang/memory/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=en href=http://localhost:1313/posts/golang/memory/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Go 内存分配器"><meta property="og:description" content="介绍了go内存分配的三级模型，还讨论了分配器的种类和设计原则，以及内存布局的组件和对象分配的流程。整体而言，Go的内存分配器通过多级缓存和分级分配的思想，提高了内存管理的效率和空间利用率。"><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/golang/memory/"><meta property="og:image" content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-02T22:39:00+08:00"><meta property="article:modified_time" content="2023-12-02T22:39:00+08:00"><meta property="og:site_name" content="Sweetpear's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Go 内存分配器"><meta name=twitter:description content="介绍了go内存分配的三级模型，还讨论了分配器的种类和设计原则，以及内存布局的组件和对象分配的流程。整体而言，Go的内存分配器通过多级缓存和分级分配的思想，提高了内存管理的效率和空间利用率。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Go 内存分配器","item":"http://localhost:1313/posts/golang/memory/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go 内存分配器","name":"Go 内存分配器","description":"介绍了go内存分配的三级模型，还讨论了分配器的种类和设计原则，以及内存布局的组件和对象分配的流程。整体而言，Go的内存分配器通过多级缓存和分级分配的思想，提高了内存管理的效率和空间利用率。","keywords":["golang","内存分配器"],"articleBody":"内存分配 参考 draveness 内存分配器\nGo语言原本 内存分配\n例子 golang的内存分配模型可以与现实中的 零售店-经销商-工厂 模式进行类比，目的都在于可以合理的分配资源以及保证高效率\n具体而言，零售店（线程缓存mcache）拥有很多种类的商品（可以看做是空闲内存空间或者内存页），每种商品由一个售货员（mspan）进行管理（记录售出状态）和负责销售，零售店的优势就在于\n离顾客（goroutine）家很近，买东西比较便捷。当顾客需要买数量较少的商品时（微对象小对象）直接去零售店就好，如果要大批量订货（大对象）则需要直接去工厂，零售店的库存肯定不够。\n当零售店库存不足时，会向经销商（mcentral）进货。经销商拥有所有种类的商品。\n当经销商也没有足够的库存时，就要向工厂（mheap）进货。工厂仓库（arena）中存着所有已经生产完的商品，当仓库中所有的货都被预定了没有可售商品时，就会找原料供应商（操作系统）进货。\n获得原料（page）后，就会进行加工并且规划一些新仓库存放（堆扩容）。\n供货链采用三个层级的策略，减少了顾客需要亲自去工厂交易的繁琐，也保证了工厂不会将大量时间花在处理小订单上边，提高了商品流通的效率。\n设计原则 分配器 线性分配器 依靠指针的增量来确定下一个可用的内存位置，需要搭配具有拷贝特性的垃圾回收算法（标记压缩、复制回收、分代回收等）整理内存碎片，JAVA采用的分配方法，对于C/C++等直接对外暴露指针的语言不适用。\n优点：复杂度较低\n缺点：无法重用回收的内存（整理碎片之前）\n空闲链表分配器 将内存块通过指针连成链表，空闲链表分配器可以选择不同的策略在链表中的内存块中进行选择。\n优点：可重用回收的内存\n缺点：分配时需要遍历链表\n四种内存分配策略 首次适应（First-Fit）— 从链表头开始遍历，选择第一个大小大于申请内存的内存块； 循环首次适应（Next-Fit）— 从上次遍历的结束位置开始遍历，选择第一个大小大于申请内存的内存块； 最优适应（Best-Fit）— 从链表头遍历整个链表，选择最合适的内存块； 隔离适应（Segregated-Fit）— 将内存分割成多个链表，每个链表中的内存块大小相同，申请内存时先找到满足条件的链表，再从链表中选择合适的内存块； 其中，隔离适应与GO使用的策略相似： 分配思想 分级分配 它将对象划分为多个不同的大小级别（go中为微对象、小对象、大对象），并使用不同的分配器来管理每个级别的内存分配。通过分级分配，可以更好地适应不同大小对象的内存需求，提高整体的内存管理效率和空间利用率。\n注：分配器和分配思想是两个不同层面的概念，分级分配是在宏观层面为新对象选择合适的缓存存储级别，而分配器则面向底层内存分配的具体实现。 内存布局 mspan是内存管理单元，负责管理内存页和分配的对象\nmcache作用相当于缓存，它缓存了一些可以直接拿来用的内存管理单元，直接满足当前线程的内存需求，不用加锁步骤简单速度很快。\nmcentral像是一个二级缓存，按种类不同每类保存一些可以拿来用的内存管理单元，方便mcache层快速获取想要的种类。\nmheap由一个个的arena构成，arena作为虚拟内存的索引可以快速定位内存中的几页。\n注：不是一个mcache对应一个mcentral哦 go1.11以前堆内存空间是连续的，1.11中改为使用稀疏内存，runtime.heapArena 管理 pagesPerArena 个页（不同平台可能不同，但页都是8KB）\n注：go语言的页（8KB）由运行时自己定义的，与操作系统的页（大部分4KB）不同。更大的页可以减少内存管理开销（小对象可以挤一挤）、提高缓存命中率（大对象不用分太碎）以及满足对齐需求。 核心组件 mspan runtime.mspan 是GO语言内存管理的基本单元，每个mspan管理npages个GO页并持有管理的页的占用情况。每个mspan作为相同spanClass大小等级的双向链表中的一个节点相互引用。\n最小分配单位是对象（object）而不是页，object的大小是由mspan的跨度类（spanClass）决定的 对象间通过 FreeList 链表形式连接。\nFreelist是一种特殊的链表形式，通过节点值的高8字节确定下个节点的内存地址，而不是传统的保存一个Next指针字段。可以节省内存。 spanClass runtime.spanClass 是mspan的跨度类，它决定了内存管理单元中存储的对象大小和个数。\n源码中预存储了67个跨度类尺寸 (size class)，运行时中还包含1个id为0的特殊跨度类，它能够管理大于 32KB 的特殊对象。\n跨度类一共有 68 * 2 = 136 个：68个尺寸（size class），每种尺寸有两个类型（ scan 和 noscan ），noscan表示对象不包含指针所以不会被GC扫描，可以提高GC效率。\n一个spanClass由一个 uint8 表示，其中高7位是id，最后一位表示 scan 或 noscan。\n在运行时分配对象时会根据对象大小选择适合的跨度类。也正是与上述隔离适应策略的相似之处。\nmcache 线程缓存，会与处理器 P 一一绑定，主要用来缓存微小对象。每一个线程缓存都在 mcache.alloc 数组中持有 68 * 2 个 runtime.mspan，每一个数组元素都是某一个特定大小的 mspan 的链表头指针。\n拥有微对象分配器，专门管理16B以下的非指针类型的对象，\n优势：由于与P绑定，所以不会有并发问题，访问时不用加锁，效率更高。（为什么不与M绑定：M可能陷入休眠状态，期间无法复用缓存）\n初始化 在初始化处理器P时会调用 runtime.allomcache 在系统栈中使用 mheap 中的线程缓存分配器进行初始化。\nmcentral 中心缓存，每个中心缓存管理一种跨度类对应的内存管理单元（mspan），总共136个由mheap保存。这些mspan由四个 spanSet 存储，分别是：\n包含空闲对象的 partial set: [swept,unswept]\n不包含空闲对象 full set: [swept,unswept]\n垃圾回收器完成对某个内存跨度的扫描和标记操作后，该内存跨度就被认为是 “swept” 访问中心缓存中的内存管理单元需要使用互斥锁：\nmheap 页堆，以全局变量形式 runtime.mheap_ 存储，包含了长度为136（scan \u0026 noscan）的mcentral数组，持有的mspan列表以及所有的 heapArena（由二维数组存储）。\nheapArena GO堆在逻辑上划分为多个 heapArena ，可以把 heapArena 看作“堆块”， 每“块”里有 heapArenaBytes / pageSize 个页， 分别由 mspan 进行管理。\n对象分配 入口: runtime.newobject，new关键字的实现\n在分配时，会占有m线程，并根据对象大小和是否为指针类型（scan）确定分配逻辑：\nif size \u003c= 32KB { if noscan \u0026\u0026 size \u003c 16B { 分配微对象 } else { 分配小对象 } } else { 分配大对象 } 大对象 对于size\u003e32KB的对象，直接在堆上进行分配。\n流程 计算需要的pages，然后进入系统栈尝试获取新的mspan\n在分配之前先回收一部分内存以避免内存大量占用\n【mheap加锁】内存分配、mspan初始化 【mheap解锁】\n从堆上分配新的内存页和内存管理单元mspan（id为0的特殊mspan），如果堆空间不足还要考虑扩容（向操作系统申请空间），如果p0上的mspan缓存 runtime.p.mspancache 不足还要用 runtime.fixalloc 分配器分配 页内存分配使用的是全局的页分配器 runtime.pageAlloc（Radix tree） 初始化刚刚获得的mspan，并且建立mheap和mspan的关系（加入heapArena.spans）\n清理新分配的内存，进行归零操作\n返回mspan中的base地址 mspan.startAddr\n小对象 对于16B\u003c=size\u003c=32KB的对象和size\u003c16但包含指针B的对象，，先后尝试从线程缓存、中心缓存、堆中获取mspan，如果没找到可用的则从操作系统分配新页\n流程 根据对象大小找到对应的跨度类，尝试从mcache的mspan数组缓存（mcache.alloc）中的获取对应的mspan，通过 mspan.allocCache（保存对象空闲状态的位图，原理：德布鲁因序列）寻找能够容纳当前对象的空闲对象内存空间，如果有则完成分配\n如果上一步没有找到分配空间，则需要调用 runtime.refill 向上级组件获取mspan替换已经不存在可用对象的当前mspan\n将当前的mspan（已满）放入 mcentral 的 full set\n尝试从 mcentral的 partial swept set获取一个mspan\n尝试从 mcentral的 partial unswept set获取一个mspan，并且sweep它\n尝试从 mcentral的 full unswept set获取一个mspan，并且sweep它， 如果sweep后发现没有空闲空间，则放到 full swept set中\n如果尝试100次获取后（go1.21）依旧没有找到可用的mspan， 则继续向堆申请\n向堆申请流程与大对象分配流程一致（只有span size不同） 初始化mspan字段以及初始化heapArena中该mspan的位图信息等字段 至此，寻找能用的mspan的流程终于结束了\n将新获取到的mspan保存在（mcache.alloc）中，并且返回新mspan中的空闲内存地址（freeIndex）\n微对象 对于size\u003c16且不包含指针（noscan）B的对象，使用mcache中的微分配器（mcache.tiny等字段）分配。主要目标是短字符串和逃逸的临时变量\n一个tiny内存块（由maxTinySize决定，16B）中可以存多个微对象，大家挤一挤从而节省了空间。而释放内存时，要等块中所有的对象都被标记为垃圾时才会进行。\n逃逸变量：函数内部定义的局部变量，但在函数结束后仍然被其他对象或函数引用的变量（指针作为返回值等）\n为什么必须要是noscan：为了保证潜在浪费的内存量是有限的（the amount of potentially wasted memory is bounded.）\n流程 先根据对象的size进行一些内存对齐的操作，调整 mcache.tinyoffset 的内存地址 为什么要内存对齐：减少 CPU 访问内存的次数。因为 CPU 是以字长为单位访问内存的而不是字节。 看看当前tiny内存块中是否装得下（tinyoffset+size \u003c= maxTinySize），装得下则直接分配，返回对象内存地址\n否则，同小对象分配流程一样获取一个mspan替换旧的tiny块，唯二不同是span size和不用对新分配的内存进行清零（why？）\n返回分配到的内存地址\n总结 GO中内存布局利用了多级缓存以及隔离适应策略（划分多个size class），优化了内存分配的效率，提高了空间利用率，并且由运行时全权管理堆区内存，方便了开发者。这也正是golang内存占用小、运行速度快、使用简便的原因之一。\n","wordCount":"259","inLanguage":"en","datePublished":"2023-12-02T22:39:00+08:00","dateModified":"2023-12-02T22:39:00+08:00","author":{"@type":"Person","name":"sweetpear"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/golang/memory/"},"publisher":{"@type":"Organization","name":"Sweetpear's Blog","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Sweetpear's Blog (Alt + H)">Sweetpear's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/archives/ title=archives><span>archives</span></a></li><li><a href=http://localhost:1313/tags/ title=tags><span>tags</span></a></li><li><a href=https://example.org title=example.org><span>example.org</span>&nbsp;<svg fill="none" shape-rendering="geometricPrecision" stroke="currentcolor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12"><path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"/><path d="M15 3h6v6"/><path d="M10 14 21 3"/></svg></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>Home</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Go 内存分配器</h1><div class=post-meta><span title='2023-12-02 22:39:00 +0800 CST'>December 2, 2023</span>&nbsp;·&nbsp;sweetpear&nbsp;|&nbsp;<a href=https://github.com/%3cpath_to_repo%3e/content/posts/golang/memory.md rel="noopener noreferrer" target=_blank>Suggest Changes</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>Table of Contents</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#参考>参考</a></li><li><a href=#例子>例子</a></li><li><a href=#设计原则>设计原则</a><ul><li><a href=#分配器>分配器</a></li><li><a href=#分配思想>分配思想</a></li><li><a href=#内存布局>内存布局</a></li></ul></li><li><a href=#核心组件>核心组件</a><ul><li><a href=#mspan>mspan</a></li><li><a href=#mcache>mcache</a></li><li><a href=#mcentral>mcentral</a></li><li><a href=#mheap>mheap</a></li></ul></li><li><a href=#对象分配>对象分配</a><ul><li><a href=#大对象>大对象</a></li><li><a href=#小对象>小对象</a></li><li><a href=#微对象>微对象</a></li></ul></li><li><a href=#总结>总结</a></li></ul></nav></div></details></div><div class=post-content><h1 id=内存分配>内存分配<a hidden class=anchor aria-hidden=true href=#内存分配>#</a></h1><h2 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h2><p><a href=https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-memory-allocator/>draveness 内存分配器</a></p><p><a href=https://golang.design/under-the-hood/zh-cn/part2runtime/ch07alloc/>Go语言原本 内存分配</a></p><h2 id=例子>例子<a hidden class=anchor aria-hidden=true href=#例子>#</a></h2><p>golang的内存分配模型可以与现实中的 零售店-经销商-工厂 模式进行类比，目的都在于可以合理的分配资源以及保证高效率</p><p>具体而言，零售店（线程缓存mcache）拥有很多种类的商品（可以看做是空闲内存空间或者内存页），每种商品由一个售货员（mspan）进行管理（记录售出状态）和负责销售，零售店的优势就在于</p><p>离顾客（goroutine）家很近，买东西比较便捷。当顾客需要买数量较少的商品时（微对象小对象）直接去零售店就好，如果要大批量订货（大对象）则需要直接去工厂，零售店的库存肯定不够。</p><p>当零售店库存不足时，会向经销商（mcentral）进货。经销商拥有所有种类的商品。</p><p>当经销商也没有足够的库存时，就要向工厂（mheap）进货。工厂仓库（arena）中存着所有已经生产完的商品，当仓库中所有的货都被预定了没有可售商品时，就会找原料供应商（操作系统）进货。</p><p>获得原料（page）后，就会进行加工并且规划一些新仓库存放（堆扩容）。</p><p>供货链采用三个层级的策略，减少了顾客需要亲自去工厂交易的繁琐，也保证了工厂不会将大量时间花在处理小订单上边，提高了商品流通的效率。</p><h2 id=设计原则>设计原则<a hidden class=anchor aria-hidden=true href=#设计原则>#</a></h2><h3 id=分配器>分配器<a hidden class=anchor aria-hidden=true href=#分配器>#</a></h3><h4 id=线性分配器>线性分配器<a hidden class=anchor aria-hidden=true href=#线性分配器>#</a></h4><p>依靠指针的增量来确定下一个可用的内存位置，需要搭配具有拷贝特性的垃圾回收算法（标记压缩、复制回收、分代回收等）整理内存碎片，JAVA采用的分配方法，对于C/C++等直接对外暴露指针的语言不适用。</p><p>优点：复杂度较低</p><p>缺点：无法重用回收的内存（整理碎片之前）</p><h4 id=空闲链表分配器>空闲链表分配器<a hidden class=anchor aria-hidden=true href=#空闲链表分配器>#</a></h4><p>将内存块通过指针连成链表，空闲链表分配器可以选择不同的策略在链表中的内存块中进行选择。</p><p>优点：可重用回收的内存</p><p>缺点：分配时需要遍历链表</p><ul><li>四种内存分配策略<ul><li>首次适应（First-Fit）— 从链表头开始遍历，选择第一个大小大于申请内存的内存块；</li><li>循环首次适应（Next-Fit）— 从上次遍历的结束位置开始遍历，选择第一个大小大于申请内存的内存块；</li><li>最优适应（Best-Fit）— 从链表头遍历整个链表，选择最合适的内存块；</li><li><strong>隔离适应（Segregated-Fit）</strong>— 将内存分割成多个链表，每个链表中的内存块大小相同，申请内存时先找到满足条件的链表，再从链表中选择合适的内存块；</li></ul></li></ul><p>其中，<strong>隔离适应</strong>与GO使用的策略相似：
<img loading=lazy src=https://img.draveness.me/2020-02-29-15829868066452-segregated-list.png alt=隔离适应></p><h3 id=分配思想>分配思想<a hidden class=anchor aria-hidden=true href=#分配思想>#</a></h3><h4 id=分级分配>分级分配<a hidden class=anchor aria-hidden=true href=#分级分配>#</a></h4><p>它将对象划分为多个不同的大小级别（go中为微对象、小对象、大对象），并使用不同的分配器来管理每个级别的内存分配。通过分级分配，可以更好地适应不同大小对象的内存需求，提高整体的内存管理效率和空间利用率。</p><ul><li>注：分配器和分配思想是两个不同层面的概念，分级分配是在宏观层面为新对象选择合适的缓存存储级别，而分配器则面向底层内存分配的具体实现。</li></ul><h3 id=内存布局>内存布局<a hidden class=anchor aria-hidden=true href=#内存布局>#</a></h3><p><img loading=lazy src=https://img.draveness.me/2020-02-29-15829868066479-go-memory-layout.png alt=布局></p><p>mspan是内存管理单元，负责管理内存页和分配的对象</p><p>mcache作用相当于缓存，它缓存了一些可以直接拿来用的内存管理单元，直接满足当前线程的内存需求，不用加锁步骤简单速度很快。</p><p>mcentral像是一个二级缓存，按种类不同每类保存一些可以拿来用的内存管理单元，方便mcache层快速获取想要的种类。</p><p>mheap由一个个的arena构成，arena作为虚拟内存的<strong>索引</strong>可以快速定位内存中的几页。</p><ul><li>注：不是一个mcache对应一个mcentral哦</li></ul><p>go1.11以前堆内存空间是连续的，1.11中改为使用稀疏内存，<code>runtime.heapArena</code> 管理 <code>pagesPerArena</code> 个页（不同平台可能不同，但<em>页</em>都是8KB）</p><ul><li>注：go语言的页（8KB）由运行时自己定义的，与操作系统的页（大部分4KB）不同。更大的页可以减少内存管理开销（小对象可以挤一挤）、提高缓存命中率（大对象不用分太碎）以及满足对齐需求。</li></ul><h2 id=核心组件>核心组件<a hidden class=anchor aria-hidden=true href=#核心组件>#</a></h2><h3 id=mspan>mspan<a hidden class=anchor aria-hidden=true href=#mspan>#</a></h3><p><code>runtime.mspan</code> 是GO语言内存管理的<strong>基本单元</strong>，每个mspan管理npages个GO页并持有管理的页的占用情况。每个mspan作为<strong>相同spanClass大小等级</strong>的双向链表中的一个节点相互引用。</p><ul><li>最小分配单位是对象（object）而不是页，object的大小是由mspan的跨度类（spanClass）决定的</li></ul><p>对象间通过 <code>FreeList</code> 链表形式连接。</p><ul><li>Freelist是一种特殊的链表形式，通过节点值的高8字节确定下个节点的内存地址，而不是传统的保存一个Next指针字段。可以节省内存。</li></ul><h4 id=spanclass>spanClass<a hidden class=anchor aria-hidden=true href=#spanclass>#</a></h4><p><code>runtime.spanClass</code> 是mspan的跨度类，它决定了内存管理单元中存储的对象大小和个数。</p><p>源码中预存储了<em>67</em>个跨度类尺寸 (size class)，运行时中还包含<em>1</em>个id为0的特殊跨度类，它能够管理大于 32KB 的特殊对象。</p><p>跨度类一共有 68 * 2 = 136 个：68个尺寸（size class），每种尺寸有两个类型（ scan 和 noscan ），noscan表示对象不包含指针所以不会被GC扫描，可以提高GC效率。</p><p>一个spanClass由一个 <code>uint8</code> 表示，其中高7位是id，最后一位表示 scan 或 noscan。</p><p>在运行时分配对象时会根据对象大小选择适合的跨度类。也正是与上述<a href=####%E7%A9%BA%E9%97%B2%E9%93%BE%E8%A1%A8%E5%88%86%E9%85%8D%E5%99%A8>隔离适应</a>策略的相似之处。</p><h3 id=mcache>mcache<a hidden class=anchor aria-hidden=true href=#mcache>#</a></h3><p>线程缓存，会与处理器 P 一一绑定，主要用来缓存微小对象。每一个线程缓存都在 <code>mcache.alloc</code> 数组中持有 68 * 2 个 <code>runtime.mspan</code>，每一个数组元素都是某一个特定大小的 mspan 的链表头指针。</p><p>拥有微对象分配器，专门管理16B以下的<strong>非指针类型</strong>的对象，</p><p>优势：由于与P绑定，所以不会有并发问题，访问时不用加锁，效率更高。（为什么不与M绑定：M可能陷入休眠状态，期间无法复用缓存）</p><h4 id=初始化>初始化<a hidden class=anchor aria-hidden=true href=#初始化>#</a></h4><p>在初始化处理器P时会调用 <code>runtime.allomcache</code> 在系统栈中使用 mheap 中的线程缓存分配器进行初始化。</p><h3 id=mcentral>mcentral<a hidden class=anchor aria-hidden=true href=#mcentral>#</a></h3><p>中心缓存，每个中心缓存管理<strong>一种跨度类</strong>对应的内存管理单元（mspan），总共136个由mheap保存。这些mspan由四个 <code>spanSet</code> 存储，分别是：</p><ul><li><p>包含空闲对象的 partial set: [swept,unswept]</p></li><li><p>不包含空闲对象 full set: [swept,unswept]</p><ul><li>垃圾回收器完成对某个内存跨度的扫描和标记操作后，该内存跨度就被认为是 &ldquo;swept&rdquo;</li></ul></li></ul><p>访问中心缓存中的内存管理单元<strong>需要使用互斥锁</strong>：</p><h3 id=mheap>mheap<a hidden class=anchor aria-hidden=true href=#mheap>#</a></h3><p>页堆，以全局变量形式 <code>runtime.mheap_</code> 存储，包含了长度为136（scan & noscan）的mcentral数组，持有的mspan列表以及所有的 <code>heapArena</code>（由二维数组存储）。</p><h4 id=heaparena>heapArena<a hidden class=anchor aria-hidden=true href=#heaparena>#</a></h4><p>GO堆在逻辑上划分为多个 <code>heapArena</code> ，可以把 heapArena 看作“堆块”， 每“块”里有 <code>heapArenaBytes / pageSize</code> 个页， 分别由 mspan 进行管理。</p><h2 id=对象分配>对象分配<a hidden class=anchor aria-hidden=true href=#对象分配>#</a></h2><p>入口: <code>runtime.newobject</code>，<code>new</code>关键字的实现</p><p>在分配时，会占有m线程，并根据对象大小和是否为指针类型（scan）确定分配逻辑：</p><pre tabindex=0><code>if size &lt;= 32KB {
    if noscan &amp;&amp; size &lt; 16B {
        分配微对象
    } else {
        分配小对象
    }
} else {
    分配大对象
}
</code></pre><h3 id=大对象>大对象<a hidden class=anchor aria-hidden=true href=#大对象>#</a></h3><p>对于size>32KB的对象，直接在堆上进行分配。</p><h4 id=流程>流程<a hidden class=anchor aria-hidden=true href=#流程>#</a></h4><ol><li><p>计算需要的pages，然后进入系统栈尝试获取新的mspan</p></li><li><p>在分配之前先回收一部分内存以避免内存大量占用</p></li><li><p>【mheap加锁】内存分配、mspan初始化 【mheap解锁】</p><ol><li>从堆上分配新的内存页和内存管理单元mspan（id为0的特殊mspan），如果堆空间不足还要考虑扩容（向操作系统申请空间），如果p0上的mspan缓存 <code>runtime.p.mspancache</code> 不足还要用 <code>runtime.fixalloc</code> 分配器分配</li></ol><ul><li>页内存分配使用的是全局的页分配器 <code>runtime.pageAlloc</code>（Radix tree）</li></ul><ol start=2><li><p>初始化刚刚获得的mspan，并且建立mheap和mspan的关系（加入heapArena.spans）</p></li><li><p>清理新分配的内存，进行归零操作</p></li></ol></li><li><p>返回mspan中的base地址 <code>mspan.startAddr</code></p></li></ol><h3 id=小对象>小对象<a hidden class=anchor aria-hidden=true href=#小对象>#</a></h3><p>对于16B&lt;=size&lt;=32KB的对象和size&lt;16但包含指针B的对象，，先后尝试从线程缓存、中心缓存、堆中获取mspan，如果没找到可用的则从操作系统分配新页</p><h4 id=流程-1>流程<a hidden class=anchor aria-hidden=true href=#流程-1>#</a></h4><ol><li><p>根据对象大小找到对应的跨度类，尝试从mcache的mspan数组缓存（<code>mcache.alloc</code>）中的获取对应的mspan，通过 <code>mspan.allocCache</code>（保存对象空闲状态的位图，原理：<a href=https://halfrost.com/go_s2_de_bruijn/>德布鲁因序列</a>）寻找能够容纳当前对象的空闲对象内存空间，如果有则完成分配</p></li><li><p>如果上一步没有找到分配空间，则需要调用 <code>runtime.refill</code> 向上级组件获取mspan替换已经不存在可用对象的当前mspan</p><ol><li><p>将当前的mspan（已满）放入 mcentral 的 full set</p></li><li><p>尝试从 mcentral的 partial swept set获取一个mspan</p></li><li><p>尝试从 mcentral的 partial unswept set获取一个mspan，并且sweep它</p></li><li><p>尝试从 mcentral的 full unswept set获取一个mspan，并且sweep它， 如果sweep后发现没有空闲空间，则放到 full swept set中</p></li><li><p>如果尝试100次获取后（go1.21）依旧没有找到可用的mspan， 则继续向堆申请</p><ol><li>向堆申请流程与<a href=####%E6%B5%81%E7%A8%8B>大对象分配流程</a>一致（只有span size不同）</li><li>初始化mspan字段以及初始化heapArena中该mspan的位图信息等字段</li></ol></li><li><p>至此，寻找能用的mspan的流程终于结束了</p></li></ol></li><li><p>将新获取到的mspan保存在（<code>mcache.alloc</code>）中，并且返回新mspan中的空闲内存地址（freeIndex）</p></li></ol><h3 id=微对象>微对象<a hidden class=anchor aria-hidden=true href=#微对象>#</a></h3><p>对于size&lt;16且不包含指针（noscan）B的对象，使用mcache中的微分配器（mcache.tiny等字段）分配。<strong>主要目标</strong>是短字符串和<strong>逃逸的临时变量</strong></p><p>一个tiny内存块（由maxTinySize决定，16B）中可以存多个微对象，大家挤一挤从而节省了空间。而释放内存时，要等块中<strong>所有的对象</strong>都被标记为垃圾时才会进行。</p><ul><li><p>逃逸变量：函数内部定义的局部变量，但在函数结束后仍然被其他对象或函数引用的变量（指针作为返回值等）</p></li><li><p>为什么必须要是noscan：为了保证潜在浪费的内存量是有限的（<code>the amount of potentially wasted memory is bounded.</code>）</p></li></ul><h4 id=流程-2>流程<a hidden class=anchor aria-hidden=true href=#流程-2>#</a></h4><ol><li>先根据对象的size进行一些内存对齐的操作，调整 <code>mcache.tinyoffset</code> 的内存地址</li></ol><ul><li>为什么要内存对齐：减少 CPU 访问内存的次数。因为 CPU 是以<strong>字长</strong>为单位访问内存的而不是字节。</li></ul><ol start=2><li><p>看看当前tiny内存块中是否装得下（<code>tinyoffset+size &lt;= maxTinySize</code>），装得下则直接分配，返回对象内存地址</p></li><li><p>否则，同<a href=#e6b581e7a88b-1>小对象分配</a>流程一样获取一个mspan替换旧的tiny块，唯二不同是span size和不用对新分配的内存进行清零（why？）</p></li><li><p>返回分配到的内存地址</p></li></ol><h2 id=总结>总结<a hidden class=anchor aria-hidden=true href=#总结>#</a></h2><p>GO中内存布局利用了多级缓存以及隔离适应策略（划分多个size class），优化了内存分配的效率，提高了空间利用率，并且由运行时全权管理堆区内存，方便了开发者。这也正是golang内存占用小、运行速度快、使用简便的原因之一。</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/golang/>Golang</a></li><li><a href=http://localhost:1313/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%99%A8/>内存分配器</a></li></ul><nav class=paginav><a class=prev href=http://localhost:1313/posts/git/git/><span class=title>« Prev</span><br><span>git 基础概念以及合并操作</span>
</a><a class=next href=http://localhost:1313/posts/golang/goroutine/><span class=title>Next »</span><br><span>Go 调度器</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Go 内存分配器 on x" href="https://x.com/intent/tweet/?text=Go%20%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%99%a8&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fgolang%2fmemory%2f&amp;hashtags=golang%2c%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%99%a8"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Go 内存分配器 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fgolang%2fmemory%2f&amp;title=Go%20%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%99%a8&amp;summary=Go%20%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%99%a8&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fgolang%2fmemory%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Go 内存分配器 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fgolang%2fmemory%2f&title=Go%20%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%99%a8"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Go 内存分配器 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fgolang%2fmemory%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Go 内存分配器 on whatsapp" href="https://api.whatsapp.com/send?text=Go%20%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%99%a8%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fgolang%2fmemory%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Go 内存分配器 on telegram" href="https://telegram.me/share/url?text=Go%20%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%99%a8&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fgolang%2fmemory%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Go 内存分配器 on ycombinator" href="https://news.ycombinator.com/submitlink?t=Go%20%e5%86%85%e5%ad%98%e5%88%86%e9%85%8d%e5%99%a8&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fgolang%2fmemory%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>Sweetpear's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="copy";function s(){t.innerHTML="copied!",setTimeout(()=>{t.innerHTML="copy"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>