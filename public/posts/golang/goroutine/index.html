<!doctype html><html lang=zh dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=40585&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Go 调度器 | Sweetpear's Blog</title>
<meta name=keywords content="golang,调度器,goroutine"><meta name=description content="介绍了goroutine和线程的区别，包括创建销毁成本、内存占用和切换成本。讲述了Go程序的执行过程和调度器的结构及调度过程。"><meta name=author content="sweetpear"><link rel=canonical href=http://localhost:40585/posts/golang/goroutine/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.3fc1ba2d14e90d33083d28e9dfdc10d8fe61b73de67e0d23e3dcdef510c9b9d2.css integrity="sha256-P8G6LRTpDTMIPSjp39wQ2P5htz3mfg0j49ze9RDJudI=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:40585/icon.png><link rel=icon type=image/png sizes=16x16 href=http://localhost:40585/icon.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:40585/icon.png><link rel=apple-touch-icon href=http://localhost:40585/icon.png><link rel=mask-icon href=http://localhost:40585/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=http://localhost:40585/posts/golang/goroutine/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Go 调度器"><meta property="og:description" content="介绍了goroutine和线程的区别，包括创建销毁成本、内存占用和切换成本。讲述了Go程序的执行过程和调度器的结构及调度过程。"><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:40585/posts/golang/goroutine/"><meta property="og:image" content="http://localhost:40585/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-11-14T17:31:00+08:00"><meta property="article:modified_time" content="2023-11-14T17:31:00+08:00"><meta property="og:site_name" content="Sweetpear's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:40585/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Go 调度器"><meta name=twitter:description content="介绍了goroutine和线程的区别，包括创建销毁成本、内存占用和切换成本。讲述了Go程序的执行过程和调度器的结构及调度过程。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:40585/posts/"},{"@type":"ListItem","position":2,"name":"Go 调度器","item":"http://localhost:40585/posts/golang/goroutine/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go 调度器","name":"Go 调度器","description":"介绍了goroutine和线程的区别，包括创建销毁成本、内存占用和切换成本。讲述了Go程序的执行过程和调度器的结构及调度过程。","keywords":["golang","调度器","goroutine"],"articleBody":"goroutine 参考 操作系统 | 进程/线程切换问题\nDraveness 调度器\nGo 程序员面试笔试宝典 调度器\nGo 特殊的goroutine\n线程和进程和goroutine (进程-\u003e线程-\u003egoroutine) goroutine和线程区别 主要三方面：创建和销毁成本、内存占用、切换成本\n进程 线程 goroutine 创建和销毁 内核级（内存空间、文件描述符等） 内核级 （优化：线程池） 用户级 切换 切换页表刷新TLB（主要影响）、PCB切换， 慢 保存各种寄存器，较慢 只保存三个：PC，SP，BP，快 内存占用 独立的虚拟内存 1MB+“guard page” 初始2KB 进程切换 = 指令序列切换 + 资源切换 线程切换 = 指令序列切换 + 共享资源 为什么线程轻量 同一个进程下，线程之间的共享内存空间（内存占用），所以创建和销毁时只需要关心自己独有的数据，还可以利用线程池进一步减小成本（创建和销毁），进行切换时不需要切换页表（切换）\n为什么goroutine更轻量 同样共享进程内存空间，且栈空间会动态变化，可以减少内存浪费（内存占用），创建和销毁由 Go 运行时（ Go runtime ）负责管理，成本很小是用户级的。（创建和销毁）只需要保存和恢复 Goroutine 的上下文信息，而不需要切换整个线程的上下文（M：N模型），减少了频繁切换的内存开销（切换）\n其实golang做的优化就是：原本每个任务都要对应一个线程，对于一个CPU来说遇到多任务并发执行的情况就要频繁切换线程（解决：等量M），并且需要从全局队列取任务，涉及到加解锁（解决：加P保存本地队列），造成资源的浪费。而 go 中只使用与机器 CPU 数量相等（默认）的线程，将相比线程更轻量的 goroutine 作为具体任务的执行载体，大部分情况下只需要通过处理器 P 和调度器在用户态进行调度，减少了线程切换带来的资源损耗。 go程序执行 go program：用户程序 runtime：runtime 是 Go 的运行时系统，它是一个在程序执行期间负责管理和支持 Go 语言特性的底层系统组件，用于支持 Goroutine 的调度、内存管理、垃圾回收、并发原语等关键功能。 Goroutine 的调度功能就是通过运行时中的 scheduler 实现的。\n调度器 scheduler 在程序运行过程中，runtime.schedt 对象只有一份实体，它负责协调和管理 goroutine 的执行。\n数据结构 runtime.schedt 结构体维护了空闲 M 列表、空闲 P 列表，全局 G 队列、dead G 缓存等等。\n所有 M 所有 P 所有 G 保存在全局变量中（allm, allp, allgs）， 调度器中只是空闲的列表 初始化 一些配置的初始化 获取 g0（ g0 在运行时系统启动时创建） 初始化 m0（初始化id以及gsignal等等） 【加锁】 初始化 GOMAXPROCS 个 P 【解锁】 关于 m0 和 g0 GMP M -\u003e P -\u003e G\nM：Machine，内核线程，即传统意义上的线程 P：Processor，处理器，运行在M上负责本地调度，减缓了全局锁的调用频率 G：Goroutine，待执行任务 G 只存在于 Go 语言的运行时，是用户态线程\n数据结构 runtime.g 结构体中包括使用的栈信息、当前绑定的M（可能为空）、抢占相关信息、调度相关信息等等\n状态 一个 G 最主要的生命周期可以概括为三个状态：\n阻塞中 例如：正在执行系统调用 _Gsyscall，运行时阻塞（channel之类的）_Gwaiting，被抢占 _Gpreempted 可运行 例如：存储在运行队列中 _Grunnable 运行中 例如：被赋予了M和P _Grunnable 此外，还有 GC 相关状态、初始化状态（_Gidle、_Gdead）等。 将空闲的G置为 _Gdead 状态可以避免 GC 扫描未初始化的栈（不知道啥意思，总之是和避免GC干啥有关）\n初始化 获取调用方 G 以及 PC；\n【锁住m0 避免抢占】用 g0 系统栈（systemstack）创建新的 G【解锁m0】（使用系统栈目的是减少栈帧的复制和管理开销，从而提高大型函数调用的性能）：\n获取 g0（启动时创建的）、p0（schedt初始化时创建） 尝试从本地或者全局 dead G 列表中获取空闲的 Goroutine (runtime.p.gFree, runtime.schedt.gFree)，如果没有空闲的则创建一个新的 G 设置其状态为 dead 并加入全局 G 列表 初始化 G 的运行现场以及需要的参数 放到运行队列中（本地p/全局schedt），根据传入的参数 next：\nnext 为 true：将 G 放到处理器的 p.runnext 上作为下一个执行的任务，如果 p.runnext 上原来有 G ，则把他踢到运行队列中； next 为 false：如果本地队列有空间则放本地，否则，就会把本地队列中的一部分 Goroutine 和待加入的 Goroutine 添加到调度器持有的全局运行队列上； 检查空闲的 P，如果有，将其唤醒（提高调度和执行效率）\nM 操作系统线程，调度器最多可以创建 10000 个线程，但是最多只会有当前机器内核数 GOMAXPROCS 个活跃线程能够正常运行。 运行时启动时不会一下创建内核数个M\n数据结构 runtime.m 结构体中包括了调度线程 g0 ，当前运行的goroutine curg 以及一些处理器相关字段、状态信息、调度相关信息等等\n状态 两种：自旋和非自旋 自旋的时候，会努力找工作（检查全局队列，查看 network poller，试图执行 gc 任务，或者“偷”工作）；找不到的时候会进入非自旋状态，之后会休眠，直到有工作需要处理时，被其他工作线程唤醒，又进入自旋状态。 初始化 创建时机：运行时系统启动时（创建m0、创建sysmon线程…）、调度M去运行P时（没有空闲M则创建新的）\nruntime.newm 为创建新的M的顶层函数，执行了分配内存、初始化部分变量、调用底层函数新建操作系统线程等。\n由汇编语言调用 runtime.mstart 启动线程，初始化PC、SP和signal等运行现场，进入调度循环。\nP P 只是处理器的抽象，而非处理器本身。负责调度本地队列中的goroutine。\n数据结构 runtime.p 结构体反向存储着线程 m ，本地G队列（环形链表）、线程缓存（mcache）以及一些调试、GC 辅助的字段\n状态 一共有五个状态：\n_Pidle：P 处于空闲 _Prunning：被 M 持有，正在执行 _Psyscall：G 陷入系统调用 _Pgcstop：被 M 持有，由于 GC 被停止 _Pdead：由于 GOMAXPROCS shrank，当前 P 不再被使用 初始化 时机：运行时启动时，内核数变化时（很少见） runtime.procresize 负责p的初始化，调用时进入 world stopped 状态；\n根据新的内核数扩容或缩减 allp 全局p列表 扩容：申请新的P对象、做一些初始化操作 缩减：释放被缩减的P所持有的资源，并置其为 _Pdead 状态 判断当前G使用的P是否应该被释放（P在被缩减的范围内），如果是，则将当前P更换为 allp[0]； 遍历全局P列表 如果本地队列为空，则置为 _Pidle 状态，放入 schedt 调度器的空闲P列表 如果本地队列不为空，则绑定一个M，加入可运行的P链表 返回可运行的P链表 调度 触发调度的条件 根据 runtime.schedule 函数的调用方，可分为以下几类：\n线程启动 runtime.mstart 和 Goroutine 执行结束时 内存同步访问时（mutex，channel等阻塞时），主动挂起 系统调用时，G 对应的 M 和 P 也阻塞在系统调用，并不会立刻发生抢占，只有当这个阻塞持续时间过长（10 ms）时，才会将 P（及之上的其他 G）抢占并分配到空闲的 M 上 协作式调度，主动让出P，发生在G时间片耗尽 系统监控、GC等 调度循环 调度函数 runtime.schedule 是一个永不返回的函数，是由每个系统线程M的g0调用的，不断寻找待运行的G并执行，在G结束后会返回调度函数开头开始下一轮循环；\n如何寻找可运行的goroutine（序号为寻找优先级） 为保证公平，每61次调度将首先从调度器（runtime.sched）全局队列中获取G；取1个直接返回。 从p本地队列获取；取runnext，不行再取队首。 从全局队列获取；偷取的G数量最多为本地队列容量的一半，最少为全局队列中的G被每个P平分到的数量。 从netpoll获取； 从其他P偷取； 如果找不到，则将m切换至休眠状态，在切换期间还会一步三回头地再确认一遍确实没有可运行的G了； 步骤1和3都是从全局队列获取，但是步骤3会获取多个G，返回全局队列的队首G，剩下的放到P的本地队列中。 怎么偷 偷取 特指从其他P中获取G。 总共尝试四次，每次都会以随机的顺序遍历所有P，直到偷到。\n前三次会选择不在空闲状态的P（从空闲的P肯定获取不到G），如果队列中有G的话，会将一半的G偷到自己的本地队列里来；\n如果前三次都没偷到，最后一次会先看runnext位置上有没有G，再看本地队列，有就偷一个，还可能窃取处理器的计时器；\n怎么执行 偷到G以后，调用 runtime.execute 让G在M上跑起来\n绑定M和G，将G置为 _Grunning 状态 通过 runtime.gogo 将G调度到当前线程上，是由汇编指令实现的 G执行完成后，转换G状态为 _Gdead，解绑G/M，将G加入gFree列表，切换回g0开始新一轮的调度 总结一下 触发调度会将当前G切换回g0，由g0进行调度操作，待找到待运行的G后，将G切换到当前M上\nTODO 信号处理机制，协作与抢占\n","wordCount":"350","inLanguage":"zh","datePublished":"2023-11-14T17:31:00+08:00","dateModified":"2023-11-14T17:31:00+08:00","author":{"@type":"Person","name":"sweetpear"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:40585/posts/golang/goroutine/"},"publisher":{"@type":"Organization","name":"Sweetpear's Blog","logo":{"@type":"ImageObject","url":"http://localhost:40585/icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:40585/ accesskey=h title="Sweetpear's Blog (Alt + H)"><img src=http://localhost:40585/icon.png alt aria-label=logo height=35>Sweetpear's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:40585/archives/ title=归档><span>归档</span></a></li><li><a href=http://localhost:40585/tags/ title=标签><span>标签</span></a></li><li><a href=http://localhost:40585/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:40585/>主页</a>&nbsp;»&nbsp;<a href=http://localhost:40585/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Go 调度器</h1><div class=post-meta><span title='2023-11-14 17:31:00 +0800 CST'>2023-11-14</span>&nbsp;·&nbsp;sweetpear&nbsp;|&nbsp;<a href=https://github.com/sweetpear0108/blog/tree/main/content/posts/golang/goroutine.md rel="noopener noreferrer" target=_blank>修改建议</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#参考>参考</a></li><li><a href=#线程和进程和goroutine-进程-线程-goroutine>线程和进程和goroutine (进程->线程->goroutine)</a><ul><li><a href=#goroutine和线程区别>goroutine和线程区别</a></li><li><a href=#为什么线程轻量>为什么线程轻量</a></li><li><a href=#为什么goroutine更轻量>为什么goroutine更轻量</a></li></ul></li><li><a href=#go程序执行>go程序执行</a></li><li><a href=#调度器-scheduler>调度器 scheduler</a><ul><li><a href=#数据结构>数据结构</a></li><li><a href=#初始化>初始化</a></li></ul></li><li><a href=#gmp>GMP</a><ul><li><a href=#g>G</a></li><li><a href=#m>M</a></li><li><a href=#p>P</a></li></ul></li><li><a href=#调度>调度</a><ul><li><a href=#触发调度的条件>触发调度的条件</a></li><li><a href=#调度循环>调度循环</a></li><li><a href=#总结一下>总结一下</a></li></ul></li><li><a href=#todo>TODO</a></li></ul></nav></div></details></div><div class=post-content><h1 id=goroutine>goroutine<a hidden class=anchor aria-hidden=true href=#goroutine>#</a></h1><h2 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h2><p><a href=https://blog.csdn.net/weixin_47187147/article/details/124474016>操作系统 | 进程/线程切换问题</a></p><p><a href=https://draveness.me/golang/docs/part3-runtime/ch06-concurrency/golang-goroutine/#m>Draveness 调度器</a></p><p><a href=https://golang.design/go-questions/sched/what-is/>Go 程序员面试笔试宝典 调度器</a></p><p><a href=https://blog.haohtml.com/archives/22353/>Go 特殊的goroutine</a></p><h2 id=线程和进程和goroutine-进程-线程-goroutine>线程和进程和goroutine (进程->线程->goroutine)<a hidden class=anchor aria-hidden=true href=#线程和进程和goroutine-进程-线程-goroutine>#</a></h2><h3 id=goroutine和线程区别>goroutine和线程区别<a hidden class=anchor aria-hidden=true href=#goroutine和线程区别>#</a></h3><p>主要<strong>三方面</strong>：创建和销毁成本、内存占用、切换成本</p><table><thead><tr><th style=text-align:left></th><th style=text-align:left>进程</th><th style=text-align:left>线程</th><th style=text-align:left>goroutine</th></tr></thead><tbody><tr><td style=text-align:left>创建和销毁</td><td style=text-align:left>内核级（内存空间、文件描述符等）</td><td style=text-align:left>内核级 （优化：线程池）</td><td style=text-align:left>用户级</td></tr><tr><td style=text-align:left>切换</td><td style=text-align:left>切换页表刷新TLB（主要影响）、PCB切换， 慢</td><td style=text-align:left>保存各种寄存器，较慢</td><td style=text-align:left>只保存三个：PC，SP，BP，快</td></tr><tr><td style=text-align:left>内存占用</td><td style=text-align:left>独立的虚拟内存</td><td style=text-align:left>1MB+“guard page”</td><td style=text-align:left>初始2KB</td></tr></tbody></table><ul><li>进程切换 = 指令序列切换 + 资源切换</li><li>线程切换 = 指令序列切换 + 共享资源</li></ul><h3 id=为什么线程轻量>为什么线程轻量<a hidden class=anchor aria-hidden=true href=#为什么线程轻量>#</a></h3><p>同一个进程下，线程之间的共享内存空间（<em>内存占用</em>），所以创建和销毁时只需要关心自己独有的数据，还可以利用线程池进一步减小成本（<em>创建和销毁</em>），进行切换时不需要切换页表（<em>切换</em>）</p><h3 id=为什么goroutine更轻量>为什么goroutine更轻量<a hidden class=anchor aria-hidden=true href=#为什么goroutine更轻量>#</a></h3><p>同样共享进程内存空间，且栈空间会动态变化，可以减少内存浪费（<em>内存占用</em>），创建和销毁由 Go 运行时（ <code>Go runtime</code> ）负责管理，成本很小是用户级的。（<em>创建和销毁</em>）只需要保存和恢复 <code>Goroutine</code> 的上下文信息，而不需要切换整个线程的上下文（M：N模型），减少了频繁切换的内存开销（<em>切换</em>）</p><ul><li>其实golang做的优化就是：原本每个任务都要对应一个线程，对于一个CPU来说遇到多任务并发执行的情况就要频繁切换线程（解决：等量M），并且需要从全局队列取任务，涉及到加解锁（解决：加P保存本地队列），造成资源的浪费。而 go 中只使用与机器 CPU 数量相等（默认）的线程，将相比线程更轻量的 <code>goroutine</code> 作为具体任务的执行载体，大部分情况下只需要通过处理器 P 和调度器在用户态进行调度，减少了线程切换带来的资源损耗。</li></ul><h2 id=go程序执行>go程序执行<a hidden class=anchor aria-hidden=true href=#go程序执行>#</a></h2><p><img loading=lazy src=https://golang.design/go-questions/sched/assets/5.png alt=go_execution></p><ul><li>go program：用户程序</li><li>runtime：<code>runtime</code> 是 Go 的运行时系统，它是一个在程序执行期间负责管理和支持 Go 语言特性的底层系统组件，用于支持 <em>Goroutine 的调度</em>、内存管理、垃圾回收、并发原语等关键功能。</li></ul><p>Goroutine 的调度功能就是通过运行时中的 <code>scheduler</code> 实现的。</p><h2 id=调度器-scheduler>调度器 scheduler<a hidden class=anchor aria-hidden=true href=#调度器-scheduler>#</a></h2><p>在程序运行过程中，<code>runtime.schedt</code> 对象只有<strong>一份</strong>实体，它负责协调和管理 goroutine 的执行。</p><h3 id=数据结构>数据结构<a hidden class=anchor aria-hidden=true href=#数据结构>#</a></h3><p><code>runtime.schedt</code> 结构体维护了<strong>空闲</strong> M 列表、<strong>空闲</strong> P 列表，全局 G 队列、dead G 缓存等等。</p><ul><li>所有 M 所有 P 所有 G 保存在全局变量中（<code>allm</code>, <code>allp</code>, <code>allgs</code>）， 调度器中只是空闲的列表</li></ul><h3 id=初始化>初始化<a hidden class=anchor aria-hidden=true href=#初始化>#</a></h3><ol><li>一些配置的初始化</li><li>获取 <code>g0</code>（ g0 在运行时系统启动时创建）</li><li>初始化 <code>m0</code>（初始化id以及gsignal等等）</li><li>【加锁】 初始化 <code>GOMAXPROCS</code> 个 <code>P</code> 【解锁】</li></ol><ul><li>关于 <code>m0</code> 和 <code>g0</code>
<img loading=lazy src=https://blogstatic.haohtml.com/uploads/2021/03/8e229b7806870bf4f17da207665b8a43.jpg alt=m0&amp;g0></li></ul><h2 id=gmp>GMP<a hidden class=anchor aria-hidden=true href=#gmp>#</a></h2><p>M -> P -> G</p><ul><li>M：Machine，内核线程，即传统意义上的线程</li><li>P：Processor，处理器，运行在M上负责本地调度，<strong>减缓了全局锁的调用频率</strong></li><li>G：Goroutine，待执行任务</li></ul><h3 id=g>G<a hidden class=anchor aria-hidden=true href=#g>#</a></h3><p>只存在于 Go 语言的运行时，是<strong>用户态</strong>线程</p><h4 id=数据结构-1>数据结构<a hidden class=anchor aria-hidden=true href=#数据结构-1>#</a></h4><p><code>runtime.g</code> 结构体中包括使用的栈信息、当前绑定的M（可能为空）、抢占相关信息、调度相关信息等等</p><h4 id=状态>状态<a hidden class=anchor aria-hidden=true href=#状态>#</a></h4><p>一个 <code>G</code> 最主要的生命周期可以概括为三个状态：</p><ul><li>阻塞中 例如：正在执行系统调用 <code>_Gsyscall</code>，运行时阻塞（channel之类的）<code>_Gwaiting</code>，被抢占 <code>_Gpreempted</code></li><li>可运行 例如：存储在运行队列中 <code>_Grunnable</code></li><li>运行中 例如：被赋予了M和P <code>_Grunnable</code></li></ul><p>此外，还有 GC 相关状态、初始化状态（<code>_Gidle</code>、<code>_Gdead</code>）等。
将空闲的G置为 <code>_Gdead</code> 状态可以避免 GC 扫描未初始化的栈（不知道啥意思，总之是和避免GC干啥有关）</p><p><img loading=lazy src=https://golang.design/go-questions/sched/assets/15.png alt=G_status></p><h4 id=初始化-1>初始化<a hidden class=anchor aria-hidden=true href=#初始化-1>#</a></h4><ol><li><p>获取调用方 <code>G</code> 以及 <code>PC</code>；</p></li><li><p>【锁住m0 避免抢占】用 <code>g0</code> 系统栈（<code>systemstack</code>）创建新的 <code>G</code>【解锁m0】（使用系统栈目的是减少栈帧的复制和管理开销，从而提高大型函数调用的性能）：</p><ol><li>获取 <code>g0</code>（启动时创建的）、<code>p0</code>（<a href=#%E8%B0%83%E5%BA%A6%E5%99%A8-scheduler>schedt初始化时创建</a>）</li><li>尝试从本地或者全局 dead G 列表中获取空闲的 Goroutine (<code>runtime.p.gFree</code>, <code>runtime.schedt.gFree</code>)，如果没有空闲的则创建一个新的 G 设置其状态为 dead 并加入全局 G 列表</li><li>初始化 G 的运行现场以及需要的参数</li></ol></li><li><p>放到运行队列中（本地p/全局schedt），根据传入的参数 <code>next</code>：</p><ul><li>next 为 true：将 G 放到处理器的 <code>p.runnext</code> 上作为下一个执行的任务，如果 <code>p.runnext</code> 上原来有 G ，则把他踢到运行队列中；</li><li>next 为 false：如果本地队列有空间则放本地，否则，就会把本地队列中的一部分 Goroutine 和待加入的 Goroutine 添加到调度器持有的全局运行队列上；</li></ul></li><li><p>检查空闲的 P，如果有，将其唤醒（提高调度和执行效率）</p></li></ol><h3 id=m>M<a hidden class=anchor aria-hidden=true href=#m>#</a></h3><p>操作系统线程，调度器最多可以创建 <code>10000</code> 个线程，但是最多只会有当前机器内核数 <code>GOMAXPROCS</code> 个活跃线程能够正常<strong>运行</strong>。
<a href=https://stackoverflow.com/a/39246575>运行时启动时不会一下创建内核数个M</a></p><h4 id=数据结构-2>数据结构<a hidden class=anchor aria-hidden=true href=#数据结构-2>#</a></h4><p><code>runtime.m</code> 结构体中包括了调度线程 <code>g0</code> ，当前运行的goroutine <code>curg</code> 以及一些处理器相关字段、状态信息、调度相关信息等等</p><h4 id=状态-1>状态<a hidden class=anchor aria-hidden=true href=#状态-1>#</a></h4><ul><li>两种：自旋和非自旋
自旋的时候，会努力找工作（检查全局队列，查看 network poller，试图执行 gc 任务，或者“偷”工作）；找不到的时候会进入非自旋状态，之后会休眠，直到有工作需要处理时，被其他工作线程唤醒，又进入自旋状态。</li></ul><p><img loading=lazy src=https://golang.design/go-questions/sched/assets/17.png alt=spinning></p><h4 id=初始化-2>初始化<a hidden class=anchor aria-hidden=true href=#初始化-2>#</a></h4><p>创建时机：运行时系统启动时（创建m0、创建sysmon线程&mldr;）、调度M去运行P时（没有空闲M则创建新的）</p><p><code>runtime.newm</code> 为创建新的M的顶层函数，执行了分配内存、初始化部分变量、调用底层函数新建操作系统线程等。</p><p>由汇编语言调用 <code>runtime.mstart</code> 启动线程，初始化PC、SP和signal等运行现场，进入调度循环。</p><h3 id=p>P<a hidden class=anchor aria-hidden=true href=#p>#</a></h3><p>P 只是处理器的<strong>抽象</strong>，而非处理器本身。负责调度本地队列中的goroutine。</p><h4 id=数据结构-3>数据结构<a hidden class=anchor aria-hidden=true href=#数据结构-3>#</a></h4><p><code>runtime.p</code> 结构体反向存储着线程 <code>m</code> ，本地G队列（环形链表）、线程缓存（<code>mcache</code>）以及一些调试、GC 辅助的字段</p><h4 id=状态-2>状态<a hidden class=anchor aria-hidden=true href=#状态-2>#</a></h4><p>一共有五个状态：</p><ul><li>_Pidle：P 处于空闲</li><li>_Prunning：被 M 持有，正在执行</li><li>_Psyscall：G 陷入系统调用</li><li>_Pgcstop：被 M 持有，由于 GC 被停止</li><li>_Pdead：由于 <code>GOMAXPROCS shrank</code>，当前 P 不再被使用</li></ul><p><img loading=lazy src=https://golang.design/go-questions/sched/assets/16.png alt=processor_state></p><h4 id=初始化-3>初始化<a hidden class=anchor aria-hidden=true href=#初始化-3>#</a></h4><p>时机：运行时启动时，内核数变化时（很少见）
<code>runtime.procresize</code> 负责p的初始化，调用时进入 <code>world stopped</code> 状态；</p><ol><li>根据新的内核数扩容或缩减 <code>allp</code> 全局p列表<ul><li>扩容：申请新的P对象、做一些初始化操作</li><li>缩减：释放被缩减的P所持有的资源，并置其为 <code>_Pdead</code> 状态</li></ul></li><li>判断当前G使用的P是否应该被释放（P在被缩减的范围内），如果是，则将当前P更换为 <code>allp[0]</code>；</li><li>遍历全局P列表<ul><li>如果本地队列为空，则置为 <code>_Pidle</code> 状态，放入 <code>schedt</code> 调度器的空闲P列表</li><li>如果本地队列不为空，则绑定一个M，加入可运行的P链表</li></ul></li><li>返回可运行的P链表</li></ol><h2 id=调度>调度<a hidden class=anchor aria-hidden=true href=#调度>#</a></h2><h3 id=触发调度的条件>触发调度的条件<a hidden class=anchor aria-hidden=true href=#触发调度的条件>#</a></h3><p>根据 <code>runtime.schedule</code> 函数的调用方，可分为以下几类：</p><ul><li>线程启动 <code>runtime.mstart</code> 和 Goroutine 执行结束时</li><li>内存同步访问时（mutex，channel等阻塞时），主动挂起</li><li>系统调用时，G 对应的 M 和 P 也阻塞在系统调用，并不会立刻发生抢占，只有当这个阻塞持续时间过长（10 ms）时，才会将 P（及之上的其他 G）抢占并分配到空闲的 M 上</li><li>协作式调度，主动让出P，发生在G时间片耗尽</li><li>系统监控、GC等</li></ul><h3 id=调度循环>调度循环<a hidden class=anchor aria-hidden=true href=#调度循环>#</a></h3><p>调度函数 <code>runtime.schedule</code> 是一个永不返回的函数，是由每个系统线程M的g0调用的，不断<strong>寻找</strong>待运行的G并<strong>执行</strong>，在G结束后会<strong>返回</strong>调度函数开头开始下一轮循环；</p><h4 id=如何寻找可运行的goroutine序号为寻找优先级>如何寻找可运行的goroutine（序号为寻找优先级）<a hidden class=anchor aria-hidden=true href=#如何寻找可运行的goroutine序号为寻找优先级>#</a></h4><ol><li>为保证公平，每61次调度将<strong>首先从调度器（<code>runtime.sched</code>）全局队列中获取G</strong>；取<strong>1</strong>个直接返回。</li><li><strong>从p本地队列获取</strong>；取runnext，不行再取队首。</li><li><strong>从全局队列获取</strong>；偷取的G数量最多为本地队列容量的<strong>一半</strong>，最少为全局队列中的G被每个P平分到的数量。</li><li><strong>从netpoll获取</strong>；</li><li><strong>从其他P偷取</strong>；</li><li>如果找不到，则将m切换至<strong>休眠</strong>状态，在切换期间还会一步三回头地再确认一遍确实没有可运行的G了；</li></ol><ul><li>步骤1和3都是从全局队列获取，但是步骤3会获取多个G，返回全局队列的队首G，剩下的放到P的本地队列中。</li></ul><h4 id=怎么偷>怎么偷<a hidden class=anchor aria-hidden=true href=#怎么偷>#</a></h4><ul><li><code>偷取</code> 特指从其他P中获取G。</li></ul><p>总共尝试四次，每次都会以随机的顺序遍历所有P，直到偷到。</p><p>前三次会选择<strong>不在</strong>空闲状态的P（从空闲的P肯定获取不到G），如果队列中有G的话，会将<strong>一半</strong>的G偷到自己的本地队列里来；</p><p>如果前三次都没偷到，最后一次会先看runnext位置上有没有G，再看本地队列，有就偷<strong>一个</strong>，还可能窃取处理器的计时器；</p><h4 id=怎么执行>怎么执行<a hidden class=anchor aria-hidden=true href=#怎么执行>#</a></h4><p>偷到G以后，调用 <code>runtime.execute</code> 让G在M上跑起来</p><ol><li>绑定M和G，将G置为 <code>_Grunning</code> 状态</li><li>通过 <code>runtime.gogo</code> 将G调度到当前线程上，是由汇编指令实现的</li><li>G执行完成后，转换G状态为 <code>_Gdead</code>，解绑G/M，将G加入gFree列表，切换回g0开始新一轮的调度</li></ol><h3 id=总结一下>总结一下<a hidden class=anchor aria-hidden=true href=#总结一下>#</a></h3><p>触发调度会将当前G切换回g0，由g0进行调度操作，待找到待运行的G后，将G切换到当前M上</p><h2 id=todo>TODO<a hidden class=anchor aria-hidden=true href=#todo>#</a></h2><p>信号处理机制，协作与抢占</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:40585/tags/golang/>Golang</a></li><li><a href=http://localhost:40585/tags/%E8%B0%83%E5%BA%A6%E5%99%A8/>调度器</a></li><li><a href=http://localhost:40585/tags/goroutine/>Goroutine</a></li></ul><nav class=paginav><a class=prev href=http://localhost:40585/posts/golang/memory/><span class=title>« 上一页</span><br><span>Go 内存分配器</span>
</a><a class=next href=http://localhost:40585/posts/golang/function_paramter_passing/><span class=title>下一页 »</span><br><span>Go 参数传递机制</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Go 调度器 on x" href="https://x.com/intent/tweet/?text=Go%20%e8%b0%83%e5%ba%a6%e5%99%a8&amp;url=http%3a%2f%2flocalhost%3a40585%2fposts%2fgolang%2fgoroutine%2f&amp;hashtags=golang%2c%e8%b0%83%e5%ba%a6%e5%99%a8%2cgoroutine"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Go 调度器 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a40585%2fposts%2fgolang%2fgoroutine%2f&amp;title=Go%20%e8%b0%83%e5%ba%a6%e5%99%a8&amp;summary=Go%20%e8%b0%83%e5%ba%a6%e5%99%a8&amp;source=http%3a%2f%2flocalhost%3a40585%2fposts%2fgolang%2fgoroutine%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Go 调度器 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a40585%2fposts%2fgolang%2fgoroutine%2f&title=Go%20%e8%b0%83%e5%ba%a6%e5%99%a8"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Go 调度器 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a40585%2fposts%2fgolang%2fgoroutine%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Go 调度器 on whatsapp" href="https://api.whatsapp.com/send?text=Go%20%e8%b0%83%e5%ba%a6%e5%99%a8%20-%20http%3a%2f%2flocalhost%3a40585%2fposts%2fgolang%2fgoroutine%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Go 调度器 on telegram" href="https://telegram.me/share/url?text=Go%20%e8%b0%83%e5%ba%a6%e5%99%a8&amp;url=http%3a%2f%2flocalhost%3a40585%2fposts%2fgolang%2fgoroutine%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Go 调度器 on ycombinator" href="https://news.ycombinator.com/submitlink?t=Go%20%e8%b0%83%e5%ba%a6%e5%99%a8&u=http%3a%2f%2flocalhost%3a40585%2fposts%2fgolang%2fgoroutine%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:40585/>Sweetpear's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>