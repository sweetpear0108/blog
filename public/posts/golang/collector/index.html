<!doctype html><html lang=zh dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=40585&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Go 垃圾收集器 | Sweetpear's Blog</title>
<meta name=keywords content="golang,垃圾收集器"><meta name=description content="该文章介绍了Go语言中的垃圾回收机制，包括算法、策略和优化技术。"><meta name=author content="sweetpear"><link rel=canonical href=http://localhost:40585/posts/golang/collector/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.3fc1ba2d14e90d33083d28e9dfdc10d8fe61b73de67e0d23e3dcdef510c9b9d2.css integrity="sha256-P8G6LRTpDTMIPSjp39wQ2P5htz3mfg0j49ze9RDJudI=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:40585/icon.png><link rel=icon type=image/png sizes=16x16 href=http://localhost:40585/icon.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:40585/icon.png><link rel=apple-touch-icon href=http://localhost:40585/icon.png><link rel=mask-icon href=http://localhost:40585/icon.png><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=http://localhost:40585/posts/golang/collector/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Go 垃圾收集器"><meta property="og:description" content="该文章介绍了Go语言中的垃圾回收机制，包括算法、策略和优化技术。"><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:40585/posts/golang/collector/"><meta property="og:image" content="http://localhost:40585/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-12-22T16:48:00+08:00"><meta property="article:modified_time" content="2023-12-22T16:48:00+08:00"><meta property="og:site_name" content="Sweetpear's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:40585/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Go 垃圾收集器"><meta name=twitter:description content="该文章介绍了Go语言中的垃圾回收机制，包括算法、策略和优化技术。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:40585/posts/"},{"@type":"ListItem","position":2,"name":"Go 垃圾收集器","item":"http://localhost:40585/posts/golang/collector/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Go 垃圾收集器","name":"Go 垃圾收集器","description":"该文章介绍了Go语言中的垃圾回收机制，包括算法、策略和优化技术。","keywords":["golang","垃圾收集器"],"articleBody":"Collector 参考 draveness垃圾收集器\ngo语言原本-垃圾回收\ngo程序员面试笔试宝典-垃圾回收器20问\n渐进式垃圾回收-CSDN\n奇伢云存储-golang混合写屏障\n设计原则 垃圾收集算法 追踪式：从根对象出发，一步步扫描回收对象\n引用计数式：对象自身包含一个被引用的计数器\n根对象是什么：全局变量、执行栈、寄存器 分代式 根据对象的存活时间进行分类。（JAVA：年轻代、老年代、永久代）\n优点：相比传统标记清除 STW 更小，分代选取不同垃圾收集策略，效率高。 缺点：额外开销，内存占用，且golang中编译器会通过逃逸分析将大部分新生对象存储在栈上（栈直接被回收），因此没必要。 标记清除 从根对象出发，将确定存活的对象进行标记，并清扫可以回收的对象。\n优点：简单 缺点：需要长时间 STW 三色标记清除 优化的标记清除算法，将对象分为三类：黑、白、灰，保证与用户程序并发执行时程序的正确性（对象不会被错误回收）\n优点：利用并发的优势，大幅减小 STW 时间 缺点：复杂，需要配合屏障技术，否则会出现悬挂指针问题（一个还在生命周期的对象被错误回收了） 收集策略 并发和增量策略都需要配合屏障技术保证回收的正确性\n增量 增量式收集是将一个完整的 GC 过程切成多个更小的 GC 时间片，穿插在用户程序之间执行，在执行时仍需要 STW。 目的：减少了每次 STW 用户程序需要等待的时间，将总等待时间分散到多个时间片中。 并发 利用多核优势在部分阶段与用户程序并行执行 目的：减少了总的 STW 时间 三色抽象 概念 三类对象：\n白色对象：未被回收器扫描到的对象。回收开始阶段全部对象都为白色，扫描结束后存在的白色对象为不可达对象。 灰色对象：已经被回收器扫描但存在指针指向一些还没被扫描白色对象。（波面） 黑色对象：对象本身以及其所有指针指向的对象都被扫描过，确定存活的对象。 三色不变性 想要在并发或者增量的标记算法中保证正确性，我们需要达成以下两种三色不变性（Tri-color invariant）中的一种：\n强三色不变性 — 黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象；（黑色不能指向白色） 弱三色不变性 — 黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径；（黑色可以指向白色，前提是必须要有另外的灰色对象直接或间接指向这个白色） 为什么要三个色？ 为了配合屏障技术，保证在并发或者增量执行时不会出现悬挂指针（本来不应该被回收的对象却被回收了）。\n具体来说，就是要保证达成至少一种三色不变性。\n屏障技术 是一种同步机制，使用户程序在进行指针写操作时，能够“通知”回收器，进而不会破坏三色不变性，保证在增量或并发回收时程序的正确性\nDijkstra 插入写屏障 在修改引用时，将新指向的对象置灰。换句话说，目的是将有存活可能的对象都标记成灰色\nwritePointer(slot, ptr): shade(ptr) *slot = ptr slot是代码中的接收位置（destination），ptr是被指向的对象，ptr需要进入slot中（goes into the slot）\n如图所示，用户程序修改A的指针，将其指向C，这时写屏障触发将C标记为灰色，在收集器启动时，将从B C 两个对象出发进行扫描。\n保证了强三色不变性。 是一种保守的屏障技术。 可能会遗留不再存活的对象，如图中的B，或者当图中第二三步间重新改变A指向B后的C。 栈上对象也需要保证回收正确性，因此需要为栈对象添加写屏障或STW并重新扫描栈上对象，GO1.7版本以前采用了后者。 Yuasa 删除写屏障 在删除引用时，如果原来指向的对象为白色，则将其置灰。目的是间接保留原有的引用关系使得扫描可以进行下去。\nwritePointer(slot, ptr) shade(*slot) *slot = ptr 第二步由于B本来就是灰色的，所以不用改；第三步将B指向C的引用删除，这时如果不将C染成灰色，后续收集器就不会扫描白色的C和D，于是CD被错误的回收了。\n如果第二步 A 指向了另外一个独立的白色对象 E 岂不是出错了？ 这种情况不可能出现，原因见下边第三点。 保证了弱三色不变性。 同样会遗留不再存活的对象。 【very important！】指针更新一定是从一个活动对象指向另一个活动对象，因为非活动对象是没有任何指针引用的，用户程序不可能再引用到它。换句话说，不可能新增一个指向孤立的白色对象的引用 混合写屏障 插入和删除写屏障都存在的问题：对栈对象加屏障严重拖累性能，尤其对于go来说（goroutine可以很多）\n如果不对栈对象加屏障，那么会导致的问题：\n只用插入屏障：一个黑色栈对象指向一个白色堆对象，并且原来灰色对象指向该白对象的指针被删除了，的会导致悬挂指针问题，需要标记后 STW 重新扫描所有栈对象。 只用删除屏障：标记结束后不需要重扫栈，但是图1-\u003e图2过程会导致悬挂指针。 因此，选择混合写屏障（插入+删除）可以避免指针悬挂问题，且不用标记结束后重新扫栈，提高了效率。\nwritePointer(slot, ptr): shade(*slot) if current stack is grey: shade(ptr) *slot = ptr 此外，要将创建的所有新对象都标记成黑色，防止新分配的对象被错误地回收。\n垃圾回收的触发 触发阈值 通过环境变量 GOGC 设置，默认为100，即增长 100% 的堆内存才会触发 GC。\n不同于进入 STW 以后进行垃圾收集的方法，并发收集器并不能等到堆内存达到触发阈值时才开始运行，因为在 GC 期间还会有用户程序在分配新的堆内存。\n所以使用 Pacing 算法计算触发 GC 的最佳时间，使得收集（标记扫描）结束时堆内存近似达到阈值\n触发时机 可以分为三种情况：\n后台定时检查，当一定时间内没有触发（默认2min），就会触发新的 GC 循环。 用户程序手动触发，如果当前没有开启 GC ，则触发新的循环。 申请内存时根据堆大小触发，当堆内存达到阈值时，则触发新的循环。 后台触发 运行时在应用程序启动时创建的一个专门用于触发垃圾收集的goroutine，大多数时间是在休眠的，由 sysmon 在满足触发条件的时候唤醒。\n手动触发 用户程序通过 runtime.GC 函数主动通知运行时执行\n分配内存 在分配微对象和小对象的内存时，如果mcache中找不到空闲内存单元，则会向下层申请mspan并触发 GC。\n在分配大对象之前，一定会先触发 GC 回收内存。\nGC 实现 核心函数 runtime.gcStart，开启一个 GC 循环。\n垃圾回收三状态 垃圾回收器通过 _GCoff、_GCMark 和 _GCMarktermination 三个标记来确定写屏障状态\n_GCoff ----\u003e _GCmark ----\u003e _GCmarktermination /\\ | |___________________________________| _GCoff：清理状态; 写屏障关闭\n_GCmark：标记状态；写屏障开启\n_GCmarktermination：标记终止状态；写屏障开启\n垃圾回收四阶段 清理终止阶段（STW）–\u003e 标记阶段 –\u003e 标记终止阶段（STW）–\u003e 清理阶段\n清理终止阶段 状态 _GCoff；所有处理器在这时进入安全点；对上个垃圾回收阶段进行一些收尾工作（例如清理缓存池、清理已经被标记的内存单元、清理标记等等）， 以及完成进入标记阶段前的一些准备工作（启动后台标记任务、更新 GC 组件中相关变量），进入 STW 状态。\n标记阶段 状态切换至 _GCmark；扫描栈上、全局变量等根对象并将它们加入队列，将所有P的微分配器中的对象置灰，以及开启写屏障，退出 STW 状态，程序恢复执行，后台标记任务开始恢复进行。\n标记终止阶段 当所有的标记任务都完成后，进入 STW 状态，状态切换至 _GCmarktermination；以及完成标记的收尾工作（统计数据、重制状态等），关闭写屏障。\n清理阶段 状态切换至 _GCoff；退出 STW 状态，后台并发清理所有的内存管理单元\n总之，在访问公共资源时需要进入 STW 状态，进行扫描标记时要开启写屏障 如何暂停和恢复程序 暂停：抢占所有的处理器P，将他们更新至 _Pgcstop 状态\n恢复：依次唤醒所有的处理器\n后台标记模式 在步骤1（标记阶段开始前），运行时会为全局每个处理器创建一个用于后台标记任务的 Goroutine（遍历 runtime.allp），这些 Goroutine 都会与P绑定成为 node结构体 被加入 runtime.gcBgMarkWorkerPool 线程池并陷入休眠等待调度器的唤醒；程序恢复后在调度循环中寻找可运行的G runtime.findrunnable 的时候被从池中取出调度到P上运行。\n这些后台标记任务被称为 gcMarkWorker\nworker有三种模式：\ngcMarkWorkerDedicatedMode：处理器专门负责标记对象，不会被调度器抢占 gcMarkWorkerFractionalMode：当垃圾收集的后台CPU 使用率达不到预期时（默认为 25%），启动该类型的工作协程帮助垃圾收集达到利用率的目标 gcMarkWorkerIdleMode：当处理器没有可以执行的 Goroutine 时，它会运行垃圾收集的标记任务直到被抢占 在调度循环中会根据全局处理器的个数以及垃圾收集的 CPU 利用率确定worker的工作模式\n三种模式相互协同保证了标记的速率，在到达堆内存触发阈值前完成标记任务\n辅助标记 在并发标记阶段期间，当 Goroutine 调用 runtime.mallocgc 分配新对象时，该函数会检查申请内存的 Goroutine 是否处于入不敷出的状态：它遵循一条非常简单并且朴实的原则，分配多少内存就需要完成多少标记任务。\n假设如果有个Goroutine一直大量的分配内存，这样有可能永远都扫描不完所有对象，或者当扫描结束时堆内存已经到了一个很夸张的大小。所以辅助标记就是为了避免这种情况。\n后台标记模式和辅助标记区别：\n后台标记是通过并发加快标记的速度，以保证到达触发阈值时完成标记任务；\n辅助标记是在后台并发标记期间，当前 goroutine 分配内存时，通过控制分配与标记的“动态平衡”，保证到达触发阈值时完成标记任务；\n观察程序GC的四种方法 GODEBUG GODEBUG=gctrace=1 ./main 输出\ngc 1 @0.000s 2%: 0.009+0.23+0.004 ms clock, 0.11+0.083/0.019/0.14+0.049 ms cpu, 4-\u003e6-\u003e2 MB, 5 MB goal, 12 P scvg: 8 KB released scvg: inuse: 3, idle: 60, sys: 63, released: 57, consumed: 6 (MB) 其中，gc开头的是用户代码向运行时申请内存产生的垃圾回收，scvg开头的是运行时向操作系统申请内存（归还内存）产生的垃圾回收\ntrace func main() { f, _ := os.Create(\"trace.out\") defer f.Close() trace.Start(f) defer trace.Stop() (...) } 通过在代码内调用trace API 来在网页内进行可视化观察\ndebug.ReadGCStats func printGCStats() { s := debug.GCStats{} debug.ReadGCStats(\u0026s) fmt.Printf(\"gc %d last@%v, PauseTotal %v\\n\", s.NumGC, s.LastGC, s.PauseTotal) } 可以搭配计时器实现对指定指标的定时监控\nruntime.ReadMemStats func printMemStats() { s := runtime.MemStats{} runtime.ReadMemStats(\u0026s) fmt.Printf(\"gc %d last@%v, next_heap_size@%vMB\\n\", s.NumGC, time.Unix(int64(time.Duration(s.LastGC).Seconds()), 0), s.NextGC/(1\u003c\u003c20)) } 和上边方法一样，只不过这里直接调用了运行时的结构体\nGC调优 调优思想：优化内存的申请速度（控制），尽可能的少申请内存（减少），复用已申请的内存（复用），减少GC触发频率（频率）\n控制：提高赋值器CPU使用率，减少花费在调度器的等待上的时间（使用 sync.WaitGroup 等并发策略避免系统中存在过多的goroutine，因为每个goroutine都会占用内存）。\n减少：合理使用数据结构\n复用：sync.Pool 等池化技术\n频率：调整GOGC上限（GOGC=1000 ./main）\n","wordCount":"372","inLanguage":"zh","datePublished":"2023-12-22T16:48:00+08:00","dateModified":"2023-12-22T16:48:00+08:00","author":{"@type":"Person","name":"sweetpear"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:40585/posts/golang/collector/"},"publisher":{"@type":"Organization","name":"Sweetpear's Blog","logo":{"@type":"ImageObject","url":"http://localhost:40585/icon.png"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:40585/ accesskey=h title="Sweetpear's Blog (Alt + H)"><img src=http://localhost:40585/icon.png alt aria-label=logo height=35>Sweetpear's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:40585/archives/ title=归档><span>归档</span></a></li><li><a href=http://localhost:40585/tags/ title=标签><span>标签</span></a></li><li><a href=http://localhost:40585/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:40585/>主页</a>&nbsp;»&nbsp;<a href=http://localhost:40585/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Go 垃圾收集器</h1><div class=post-meta><span title='2023-12-22 16:48:00 +0800 CST'>2023-12-22</span>&nbsp;·&nbsp;sweetpear&nbsp;|&nbsp;<a href=https://github.com/sweetpear0108/blog/tree/main/content/posts/golang/collector.md rel="noopener noreferrer" target=_blank>修改建议</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#参考>参考</a></li><li><a href=#设计原则>设计原则</a><ul><li><a href=#垃圾收集算法>垃圾收集算法</a></li><li><a href=#收集策略>收集策略</a></li><li><a href=#三色抽象>三色抽象</a></li><li><a href=#屏障技术>屏障技术</a></li></ul></li><li><a href=#垃圾回收的触发>垃圾回收的触发</a><ul><li><a href=#触发阈值>触发阈值</a></li><li><a href=#触发时机>触发时机</a></li></ul></li><li><a href=#gc-实现>GC 实现</a><ul><li><a href=#垃圾回收三状态>垃圾回收三状态</a></li><li><a href=#垃圾回收四阶段>垃圾回收四阶段</a></li></ul></li><li><a href=#观察程序gc的四种方法>观察程序GC的四种方法</a><ul><li><a href=#godebug>GODEBUG</a></li><li><a href=#trace>trace</a></li><li><a href=#debugreadgcstats>debug.ReadGCStats</a></li><li><a href=#runtimereadmemstats>runtime.ReadMemStats</a></li></ul></li><li><a href=#gc调优>GC调优</a></li></ul></nav></div></details></div><div class=post-content><h1 id=collector>Collector<a hidden class=anchor aria-hidden=true href=#collector>#</a></h1><h2 id=参考>参考<a hidden class=anchor aria-hidden=true href=#参考>#</a></h2><p><a href=https://draveness.me/golang/docs/part3-runtime/ch07-memory/golang-garbage-collector/#72-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8>draveness垃圾收集器</a></p><p><a href=https://golang.design/under-the-hood/zh-cn/part2runtime/ch08gc/>go语言原本-垃圾回收</a></p><p><a href=https://golang.design/go-questions/memgc/principal/>go程序员面试笔试宝典-垃圾回收器20问</a></p><p><a href=https://blog.csdn.net/puss0/article/details/126357922>渐进式垃圾回收-CSDN</a></p><p><a href=https://liqingqiya.github.io/golang/gc/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/%E5%86%99%E5%B1%8F%E9%9A%9C/2020/07/24/gc5.html>奇伢云存储-golang混合写屏障</a></p><h2 id=设计原则>设计原则<a hidden class=anchor aria-hidden=true href=#设计原则>#</a></h2><h3 id=垃圾收集算法>垃圾收集算法<a hidden class=anchor aria-hidden=true href=#垃圾收集算法>#</a></h3><ul><li><p>追踪式：从根对象出发，一步步扫描回收对象</p></li><li><p>引用计数式：对象自身包含一个被引用的计数器</p><ul><li>根对象是什么：全局变量、执行栈、寄存器</li></ul></li></ul><h4 id=分代式>分代式<a hidden class=anchor aria-hidden=true href=#分代式>#</a></h4><p>根据对象的存活时间进行分类。（JAVA：年轻代、老年代、永久代）</p><ul><li>优点：相比传统标记清除 STW 更小，分代选取不同垃圾收集策略，效率高。</li><li>缺点：额外开销，内存占用，且golang中编译器会通过逃逸分析将大部分新生对象存储在栈上（栈直接被回收），因此没必要。</li></ul><h4 id=标记清除>标记清除<a hidden class=anchor aria-hidden=true href=#标记清除>#</a></h4><p>从根对象出发，将确定存活的对象进行标记，并清扫可以回收的对象。</p><ul><li>优点：简单</li><li>缺点：需要长时间 STW</li></ul><h4 id=三色标记清除>三色标记清除<a hidden class=anchor aria-hidden=true href=#三色标记清除>#</a></h4><p>优化的标记清除算法，将对象分为<strong>三类</strong>：黑、白、灰，保证与用户程序<strong>并发执行</strong>时程序的正确性（对象不会被错误回收）</p><ul><li>优点：利用并发的优势，大幅减小 STW 时间</li><li>缺点：复杂，需要配合<strong>屏障技术</strong>，否则会出现悬挂指针问题（一个还在生命周期的对象被错误回收了）</li></ul><h3 id=收集策略>收集策略<a hidden class=anchor aria-hidden=true href=#收集策略>#</a></h3><p>并发和增量策略都需要配合<a href=###%E5%B1%8F%E9%9A%9C%E6%8A%80%E6%9C%AF>屏障技术</a>保证回收的正确性</p><h4 id=增量>增量<a hidden class=anchor aria-hidden=true href=#增量>#</a></h4><p>增量式收集是将一个完整的 GC 过程切成多个更小的 GC 时间片，穿插在用户程序之间执行，在执行时仍需要 STW。
目的：减少了每次 STW 用户程序需要等待的时间，将总等待时间分散到多个时间片中。
<img loading=lazy src=https://img.draveness.me/2020-03-16-15843705141864-incremental-collector.png alt=increment></p><h4 id=并发>并发<a hidden class=anchor aria-hidden=true href=#并发>#</a></h4><p>利用多核优势在部分阶段与用户程序并行执行
目的：减少了总的 STW 时间
<img loading=lazy src=https://img.draveness.me/2020-03-16-15843705141871-concurrent-collector.png alt=concurrent></p><h3 id=三色抽象>三色抽象<a hidden class=anchor aria-hidden=true href=#三色抽象>#</a></h3><h4 id=概念>概念<a hidden class=anchor aria-hidden=true href=#概念>#</a></h4><p>三类对象：</p><ul><li>白色对象：未被回收器扫描到的对象。回收开始阶段全部对象都为白色，扫描结束后存在的白色对象为不可达对象。</li><li>灰色对象：已经被回收器扫描但存在指针指向一些还没被扫描白色对象。（<strong>波面</strong>）</li><li>黑色对象：对象本身以及其所有指针指向的对象都被扫描过，确定存活的对象。</li></ul><h4 id=三色不变性>三色不变性<a hidden class=anchor aria-hidden=true href=#三色不变性>#</a></h4><p>想要在并发或者增量的标记算法中保证正确性，我们需要达成以下两种三色不变性（Tri-color invariant）中的一种：</p><ul><li>强三色不变性 — 黑色对象不会指向白色对象，只会指向灰色对象或者黑色对象；（黑色不能指向白色）</li><li>弱三色不变性 — 黑色对象指向的白色对象必须包含一条从灰色对象经由多个白色对象的可达路径；（黑色可以指向白色，前提是必须要有另外的灰色对象直接或间接指向这个白色）</li></ul><h4 id=为什么要三个色>为什么要三个色？<a hidden class=anchor aria-hidden=true href=#为什么要三个色>#</a></h4><p>为了配合屏障技术，保证在<a href=#%E6%94%B6%E9%9B%86%E7%AD%96%E7%95%A5>并发或者增量</a>执行时不会出现<strong>悬挂指针</strong>（本来不应该被回收的对象却被回收了）。</p><p>具体来说，就是要保证达成至少一种三色不变性。</p><h3 id=屏障技术>屏障技术<a hidden class=anchor aria-hidden=true href=#屏障技术>#</a></h3><p>是一种同步机制，使用户程序在进行指针写操作时，能够“通知”回收器，进而不会破坏三色不变性，保证在增量或并发回收时程序的正确性</p><h4 id=dijkstra-插入写屏障>Dijkstra 插入写屏障<a hidden class=anchor aria-hidden=true href=#dijkstra-插入写屏障>#</a></h4><p>在修改引用时，将<strong>新</strong>指向的对象置灰。换句话说，目的是将有存活可能的对象都标记成灰色</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=nf>writePointer</span><span class=p>(</span><span class=nx>slot</span><span class=p>,</span> <span class=nx>ptr</span><span class=p>):</span>
</span></span><span class=line><span class=cl>    <span class=nf>shade</span><span class=p>(</span><span class=nx>ptr</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=o>*</span><span class=nx>slot</span> <span class=p>=</span> <span class=nx>ptr</span>
</span></span></code></pre></div><p>slot是代码中的接收位置（destination），ptr是被指向的对象，ptr需要进入slot中（goes into the slot）</p><p><img loading=lazy src=https://img.draveness.me/2020-03-16-15843705141840-dijkstra-insert-write-barrier.png alt=dijkstra></p><p>如图所示，用户程序修改A的指针，将其指向C，这时写屏障触发将C标记为灰色，在收集器启动时，将从B C 两个对象出发进行扫描。</p><ul><li>保证了<strong>强</strong>三色不变性。</li><li>是一种<strong>保守</strong>的屏障技术。</li><li>可能会遗留不再存活的对象，如图中的B，或者当图中第二三步间重新改变A指向B后的C。</li><li>栈上对象也需要保证回收正确性，因此需要为栈对象添加写屏障或STW并重新扫描栈上对象，GO1.7版本以前采用了后者。</li></ul><h4 id=yuasa-删除写屏障>Yuasa 删除写屏障<a hidden class=anchor aria-hidden=true href=#yuasa-删除写屏障>#</a></h4><p>在删除引用时，如果<strong>原来</strong>指向的对象为白色，则将其置灰。目的是间接保留原有的引用关系使得扫描可以进行下去。</p><pre tabindex=0><code>writePointer(slot, ptr)
    shade(*slot)
    *slot = ptr
</code></pre><p><img loading=lazy src=https://img.draveness.me/2021-01-02-16095599123266-yuasa-delete-write-barrier.png alt=yuasa></p><p>第二步由于B本来就是灰色的，所以不用改；第三步将B指向C的引用删除，这时如果不将C染成灰色，后续收集器就不会扫描白色的C和D，于是CD被错误的回收了。</p><pre tabindex=0><code>如果第二步 A 指向了另外一个独立的白色对象 E 岂不是出错了？
这种情况不可能出现，原因见下边第三点。
</code></pre><ul><li>保证了<strong>弱</strong>三色不变性。</li><li>同样会遗留不再存活的对象。</li><li>【very important！】<strong>指针更新一定是从一个活动对象指向另一个活动对象，因为非活动对象是没有任何指针引用的，用户程序不可能再引用到它。换句话说，不可能新增一个指向孤立的白色对象的引用</strong></li></ul><h4 id=混合写屏障>混合写屏障<a hidden class=anchor aria-hidden=true href=#混合写屏障>#</a></h4><p>插入和删除写屏障都存在的问题：对栈对象加屏障严重拖累性能，尤其对于go来说（goroutine可以很多）</p><p>如果不对栈对象加屏障，那么会导致的问题：</p><ul><li>只用插入屏障：一个黑色栈对象指向一个白色堆对象，并且原来灰色对象指向该白对象的指针被删除了，的会导致悬挂指针问题，需要标记后 STW 重新扫描所有栈对象。</li><li>只用删除屏障：标记结束后不需要重扫栈，但是图1->图2过程会导致悬挂指针。</li></ul><p><img loading=lazy src=https://cdn.jsdelivr.net/gh/liqingqiya/liqingqiya.github.io/images/posts/2020-07-25-gc5/39D8A3CD-C763-4893-996E-27DE39AE3CFB.png alt=1>
<img loading=lazy src=https://cdn.jsdelivr.net/gh/liqingqiya/liqingqiya.github.io/images/posts/2020-07-25-gc5/A1873F49-31DE-47AD-835C-36007D34FBFB.png alt=2></p><p>因此，选择混合写屏障（插入+删除）可以避免指针悬挂问题，且不用标记结束后重新扫栈，提高了效率。</p><pre tabindex=0><code>writePointer(slot, ptr):
    shade(*slot)
    if current stack is grey:
        shade(ptr)
    *slot = ptr
</code></pre><p>此外，要将创建的所有<strong>新</strong>对象都标记成黑色，防止新分配的对象被错误地回收。</p><h2 id=垃圾回收的触发>垃圾回收的触发<a hidden class=anchor aria-hidden=true href=#垃圾回收的触发>#</a></h2><h3 id=触发阈值>触发阈值<a hidden class=anchor aria-hidden=true href=#触发阈值>#</a></h3><p>通过环境变量 <code>GOGC</code> 设置，默认为100，即增长 100% 的堆内存才会触发 GC。</p><p>不同于进入 STW 以后进行垃圾收集的方法，并发收集器并不能等到堆内存达到触发阈值时才开始运行，因为在 GC 期间还会有用户程序在分配新的堆内存。</p><p>所以使用 Pacing 算法计算触发 GC 的最佳时间，使得收集（标记扫描）结束时堆内存近似达到阈值</p><h3 id=触发时机>触发时机<a hidden class=anchor aria-hidden=true href=#触发时机>#</a></h3><p>可以分为三种情况：</p><ol><li>后台定时检查，当一定时间内没有触发（默认2min），就会触发新的 GC 循环。</li><li>用户程序手动触发，如果当前没有开启 GC ，则触发新的循环。</li><li>申请内存时根据堆大小触发，当堆内存达到阈值时，则触发新的循环。</li></ol><h4 id=后台触发>后台触发<a hidden class=anchor aria-hidden=true href=#后台触发>#</a></h4><p>运行时在应用程序启动时创建的一个专门用于触发垃圾收集的goroutine，大多数时间是在休眠的，由 sysmon 在满足触发条件的时候唤醒。</p><h4 id=手动触发>手动触发<a hidden class=anchor aria-hidden=true href=#手动触发>#</a></h4><p>用户程序通过 <code>runtime.GC</code> 函数主动通知运行时执行</p><h4 id=分配内存>分配内存<a hidden class=anchor aria-hidden=true href=#分配内存>#</a></h4><p>在分配微对象和小对象的内存时，如果mcache中找不到空闲内存单元，则会向下层申请mspan并触发 GC。</p><p>在分配大对象之前，一定会先触发 GC 回收内存。</p><h2 id=gc-实现>GC 实现<a hidden class=anchor aria-hidden=true href=#gc-实现>#</a></h2><p>核心函数 <code>runtime.gcStart</code>，开启一个 GC 循环。</p><h3 id=垃圾回收三状态>垃圾回收三状态<a hidden class=anchor aria-hidden=true href=#垃圾回收三状态>#</a></h3><p>垃圾回收器通过 _GCoff、_GCMark 和 _GCMarktermination 三个标记来确定写屏障状态</p><pre tabindex=0><code>_GCoff  ----&gt;  _GCmark  ----&gt;  _GCmarktermination
   /\                                  |
   |___________________________________|
</code></pre><ul><li><p>_GCoff：清理状态; 写屏障<strong>关闭</strong></p></li><li><p>_GCmark：标记状态；写屏障<strong>开启</strong></p></li><li><p>_GCmarktermination：标记终止状态；写屏障<strong>开启</strong></p></li></ul><h3 id=垃圾回收四阶段>垃圾回收四阶段<a hidden class=anchor aria-hidden=true href=#垃圾回收四阶段>#</a></h3><p>清理终止阶段（STW）&ndash;> 标记阶段 &ndash;> 标记终止阶段（STW）&ndash;> 清理阶段</p><ol><li>清理终止阶段</li></ol><p>状态 <code>_GCoff</code>；所有处理器在这时进入安全点；对上个垃圾回收阶段进行一些收尾工作（例如清理缓存池、清理已经被标记的内存单元、清理标记等等），
以及完成进入标记阶段前的一些准备工作（<a href=#%E5%90%8E%E5%8F%B0%E6%A0%87%E8%AE%B0%E6%A8%A1%E5%BC%8F>启动后台标记任务</a>、更新 GC 组件中相关变量），<strong>进入 STW 状态</strong>。</p><ol start=2><li>标记阶段</li></ol><p>状态切换至 <code>_GCmark</code>；扫描栈上、全局变量等根对象并将它们加入队列，将所有P的微分配器中的对象置灰，以及<strong>开启写屏障</strong>，<strong>退出 STW 状态</strong>，程序恢复执行，后台标记任务开始恢复进行。</p><ol start=3><li>标记终止阶段</li></ol><p>当所有的标记任务都完成后，<strong>进入 STW 状态</strong>，状态切换至 <code>_GCmarktermination</code>；以及完成标记的收尾工作（统计数据、重制状态等），<strong>关闭写屏障</strong>。</p><ol start=4><li>清理阶段</li></ol><p>状态切换至 <code>_GCoff</code>；<strong>退出 STW 状态</strong>，后台并发清理所有的内存管理单元</p><ul><li>总之，在访问公共资源时需要进入 STW 状态，进行扫描标记时要开启写屏障</li></ul><h4 id=如何暂停和恢复程序>如何暂停和恢复程序<a hidden class=anchor aria-hidden=true href=#如何暂停和恢复程序>#</a></h4><p>暂停：抢占所有的处理器P，将他们更新至 <code>_Pgcstop</code> 状态</p><p>恢复：依次唤醒所有的处理器</p><h4 id=后台标记模式>后台标记模式<a hidden class=anchor aria-hidden=true href=#后台标记模式>#</a></h4><p>在步骤1（标记阶段开始前），运行时会为全局<strong>每个处理器</strong>创建一个用于后台标记任务的 Goroutine（遍历 <code>runtime.allp</code>），这些 Goroutine 都会与P绑定成为 node结构体 被加入 <code>runtime.gcBgMarkWorkerPool</code> <strong>线程池</strong>并<strong>陷入休眠</strong>等待调度器的唤醒；程序恢复后在调度循环中寻找可运行的G <code>runtime.findrunnable</code> 的时候被从池中取出调度到P上运行。</p><p>这些后台标记任务被称为 <code>gcMarkWorker</code></p><p>worker有三种模式：</p><ol><li>gcMarkWorkerDedicatedMode：处理器专门负责标记对象，<strong>不会被调度器抢占</strong></li><li>gcMarkWorkerFractionalMode：当垃圾收集的后台<strong>CPU 使用率</strong>达不到预期时（默认为 25%），启动该类型的工作协程帮助垃圾收集达到利用率的目标</li><li>gcMarkWorkerIdleMode：当处理器<strong>没有</strong>可以执行的 Goroutine 时，它会运行垃圾收集的标记任务<strong>直到被抢占</strong></li></ol><p>在调度循环中会根据全局处理器的个数以及垃圾收集的 CPU 利用率确定worker的工作模式</p><p>三种模式相互协同保证了标记的速率，在到达<a href=#%E8%A7%A6%E5%8F%91%E9%98%88%E5%80%BC>堆内存触发阈值</a>前完成标记任务</p><h4 id=辅助标记>辅助标记<a hidden class=anchor aria-hidden=true href=#辅助标记>#</a></h4><p>在并发标记阶段期间，当 Goroutine 调用 <code>runtime.mallocgc</code> 分配新对象时，该函数会检查申请内存的 Goroutine 是否处于入不敷出的状态：它遵循一条非常简单并且朴实的原则，分配多少内存就需要完成多少标记任务。</p><ul><li><p>假设如果有个Goroutine一直大量的分配内存，这样有可能永远都扫描不完所有对象，或者当扫描结束时堆内存已经到了一个很夸张的大小。所以辅助标记就是为了避免这种情况。</p></li><li><p>后台标记模式和辅助标记区别：</p></li></ul><p>后台标记是通过<strong>并发</strong>加快标记的速度，以保证到达触发阈值时完成标记任务；</p><p>辅助标记是在后台并发标记<strong>期间</strong>，<strong>当前</strong> goroutine <strong>分配内存</strong>时，通过控制分配与标记的“动态平衡”，保证到达触发阈值时完成标记任务；</p><h2 id=观察程序gc的四种方法>观察程序GC的四种方法<a hidden class=anchor aria-hidden=true href=#观察程序gc的四种方法>#</a></h2><h3 id=godebug>GODEBUG<a hidden class=anchor aria-hidden=true href=#godebug>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl><span class=nv>GODEBUG</span><span class=o>=</span><span class=nv>gctrace</span><span class=o>=</span><span class=m>1</span> ./main
</span></span></code></pre></div><p>输出</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-shell data-lang=shell><span class=line><span class=cl>gc <span class=m>1</span> @0.000s 2%: 0.009+0.23+0.004 ms clock, 0.11+0.083/0.019/0.14+0.049 ms cpu, 4-&gt;6-&gt;2 MB, <span class=m>5</span> MB goal, <span class=m>12</span> P
</span></span><span class=line><span class=cl>scvg: <span class=m>8</span> KB released
</span></span><span class=line><span class=cl>scvg: inuse: 3, idle: 60, sys: 63, released: 57, consumed: <span class=m>6</span> <span class=o>(</span>MB<span class=o>)</span>
</span></span></code></pre></div><p>其中，gc开头的是用户代码向运行时申请内存产生的垃圾回收，scvg开头的是运行时向操作系统申请内存（归还内存）产生的垃圾回收</p><h3 id=trace>trace<a hidden class=anchor aria-hidden=true href=#trace>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>main</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>f</span><span class=p>,</span> <span class=nx>_</span> <span class=o>:=</span> <span class=nx>os</span><span class=p>.</span><span class=nf>Create</span><span class=p>(</span><span class=s>&#34;trace.out&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>f</span><span class=p>.</span><span class=nf>Close</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=nx>trace</span><span class=p>.</span><span class=nf>Start</span><span class=p>(</span><span class=nx>f</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=k>defer</span> <span class=nx>trace</span><span class=p>.</span><span class=nf>Stop</span><span class=p>()</span>
</span></span><span class=line><span class=cl>	<span class=p>(</span><span class=o>...</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>通过在代码内调用trace API 来在网页内进行可视化观察</p><h3 id=debugreadgcstats>debug.ReadGCStats<a hidden class=anchor aria-hidden=true href=#debugreadgcstats>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>printGCStats</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>s</span> <span class=o>:=</span> <span class=nx>debug</span><span class=p>.</span><span class=nx>GCStats</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>	<span class=nx>debug</span><span class=p>.</span><span class=nf>ReadGCStats</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;gc %d last@%v, PauseTotal %v\n&#34;</span><span class=p>,</span> <span class=nx>s</span><span class=p>.</span><span class=nx>NumGC</span><span class=p>,</span> <span class=nx>s</span><span class=p>.</span><span class=nx>LastGC</span><span class=p>,</span> <span class=nx>s</span><span class=p>.</span><span class=nx>PauseTotal</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>可以搭配计时器实现对指定指标的定时监控</p><h3 id=runtimereadmemstats>runtime.ReadMemStats<a hidden class=anchor aria-hidden=true href=#runtimereadmemstats>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-go data-lang=go><span class=line><span class=cl><span class=kd>func</span> <span class=nf>printMemStats</span><span class=p>()</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>	<span class=nx>s</span> <span class=o>:=</span> <span class=nx>runtime</span><span class=p>.</span><span class=nx>MemStats</span><span class=p>{}</span>
</span></span><span class=line><span class=cl>    <span class=nx>runtime</span><span class=p>.</span><span class=nf>ReadMemStats</span><span class=p>(</span><span class=o>&amp;</span><span class=nx>s</span><span class=p>)</span>
</span></span><span class=line><span class=cl>	<span class=nx>fmt</span><span class=p>.</span><span class=nf>Printf</span><span class=p>(</span><span class=s>&#34;gc %d last@%v, next_heap_size@%vMB\n&#34;</span><span class=p>,</span> <span class=nx>s</span><span class=p>.</span><span class=nx>NumGC</span><span class=p>,</span> <span class=nx>time</span><span class=p>.</span><span class=nf>Unix</span><span class=p>(</span><span class=nb>int64</span><span class=p>(</span><span class=nx>time</span><span class=p>.</span><span class=nf>Duration</span><span class=p>(</span><span class=nx>s</span><span class=p>.</span><span class=nx>LastGC</span><span class=p>).</span><span class=nf>Seconds</span><span class=p>()),</span> <span class=mi>0</span><span class=p>),</span> <span class=nx>s</span><span class=p>.</span><span class=nx>NextGC</span><span class=o>/</span><span class=p>(</span><span class=mi>1</span><span class=o>&lt;&lt;</span><span class=mi>20</span><span class=p>))</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>和上边方法一样，只不过这里直接调用了运行时的结构体</p><h2 id=gc调优>GC调优<a hidden class=anchor aria-hidden=true href=#gc调优>#</a></h2><p>调优思想：优化内存的申请速度（控制），尽可能的少申请内存（减少），复用已申请的内存（复用），减少GC触发频率（频率）</p><p>控制：提高赋值器CPU使用率，减少花费在调度器的等待上的时间（使用 <code>sync.WaitGroup</code> 等并发策略避免系统中存在过多的goroutine，因为每个goroutine都会占用内存）。</p><p>减少：合理使用数据结构</p><p>复用：sync.Pool 等池化技术</p><p>频率：调整GOGC上限（<code>GOGC=1000 ./main</code>）</p></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:40585/tags/golang/>Golang</a></li><li><a href=http://localhost:40585/tags/%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/>垃圾收集器</a></li></ul><nav class=paginav><a class=prev href=http://localhost:40585/posts/golang/init/><span class=title>« 上一页</span><br><span>Go init函数</span>
</a><a class=next href=http://localhost:40585/posts/git/git/><span class=title>下一页 »</span><br><span>git 基础概念以及合并操作</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Go 垃圾收集器 on x" href="https://x.com/intent/tweet/?text=Go%20%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8&amp;url=http%3a%2f%2flocalhost%3a40585%2fposts%2fgolang%2fcollector%2f&amp;hashtags=golang%2c%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Go 垃圾收集器 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a40585%2fposts%2fgolang%2fcollector%2f&amp;title=Go%20%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8&amp;summary=Go%20%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8&amp;source=http%3a%2f%2flocalhost%3a40585%2fposts%2fgolang%2fcollector%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Go 垃圾收集器 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a40585%2fposts%2fgolang%2fcollector%2f&title=Go%20%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Go 垃圾收集器 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a40585%2fposts%2fgolang%2fcollector%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Go 垃圾收集器 on whatsapp" href="https://api.whatsapp.com/send?text=Go%20%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8%20-%20http%3a%2f%2flocalhost%3a40585%2fposts%2fgolang%2fcollector%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Go 垃圾收集器 on telegram" href="https://telegram.me/share/url?text=Go%20%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8&amp;url=http%3a%2f%2flocalhost%3a40585%2fposts%2fgolang%2fcollector%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Go 垃圾收集器 on ycombinator" href="https://news.ycombinator.com/submitlink?t=Go%20%e5%9e%83%e5%9c%be%e6%94%b6%e9%9b%86%e5%99%a8&u=http%3a%2f%2flocalhost%3a40585%2fposts%2fgolang%2fcollector%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:40585/>Sweetpear's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>