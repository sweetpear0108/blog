<!doctype html><html lang=zh dir=auto><head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Postgres 批量删除语句超时 | Sweetpear's Blog</title>
<meta name=keywords content="postgres,优化器,索引"><meta name=description content='Postgres 批量删除语句超时 场景 播放记录表history中大约有将近10亿条数据，为了减少内存占用，后台任务以每秒一次的速度删除超过1年未更新的旧记录。
表结构（示意结构） Table "public.history" Column | Type | Collation | Nullable | Default --------+--------+-----------+----------+--------- uid | text | | not null | vid | text | | not null | ts | bigint | | not null | Indexes: "history_pkey" PRIMARY KEY, btree (uid, vid) "history_ts" btree (ts) 删除语句 delete from history where (uid, vid) in (select uid, vid from history where ts <= $1 limit 500) 问题出现 任务稳定运行了一年多的时间，突然有一天线上日志出现了大量的超时报错，排查后发现是pg执行删除语句的时候超过了最大时限 pq: canceling statement due to user request'><meta name=author content="sweetpear"><link rel=canonical href=http://localhost:1313/posts/postgres/pg_timeout/><meta name=google-site-verification content="XYZabc"><meta name=yandex-verification content="XYZabc"><meta name=msvalidate.01 content="XYZabc"><link crossorigin=anonymous href=/assets/css/stylesheet.b609c58d5c11bb90b1a54e04005d74ad1ddf22165eb79f5533967e57df9c3b50.css integrity="sha256-tgnFjVwRu5CxpU4EAF10rR3fIhZet59VM5Z+V9+cO1A=" rel="preload stylesheet" as=style><link rel=icon href=http://localhost:1313/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://localhost:1313/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://localhost:1313/favicon-32x32.png><link rel=apple-touch-icon href=http://localhost:1313/apple-touch-icon.png><link rel=mask-icon href=http://localhost:1313/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=http://localhost:1313/posts/postgres/pg_timeout/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="Postgres 批量删除语句超时"><meta property="og:description" content='Postgres 批量删除语句超时 场景 播放记录表history中大约有将近10亿条数据，为了减少内存占用，后台任务以每秒一次的速度删除超过1年未更新的旧记录。
表结构（示意结构） Table "public.history" Column | Type | Collation | Nullable | Default --------+--------+-----------+----------+--------- uid | text | | not null | vid | text | | not null | ts | bigint | | not null | Indexes: "history_pkey" PRIMARY KEY, btree (uid, vid) "history_ts" btree (ts) 删除语句 delete from history where (uid, vid) in (select uid, vid from history where ts <= $1 limit 500) 问题出现 任务稳定运行了一年多的时间，突然有一天线上日志出现了大量的超时报错，排查后发现是pg执行删除语句的时候超过了最大时限 pq: canceling statement due to user request'><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/posts/postgres/pg_timeout/"><meta property="og:image" content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta property="article:section" content="posts"><meta property="article:published_time" content="2024-03-16T17:26:22+08:00"><meta property="article:modified_time" content="2024-03-16T17:26:22+08:00"><meta property="og:site_name" content="Sweetpear's Blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="http://localhost:1313/%3Clink%20or%20path%20of%20image%20for%20opengraph,%20twitter-cards%3E"><meta name=twitter:title content="Postgres 批量删除语句超时"><meta name=twitter:description content='Postgres 批量删除语句超时 场景 播放记录表history中大约有将近10亿条数据，为了减少内存占用，后台任务以每秒一次的速度删除超过1年未更新的旧记录。
表结构（示意结构） Table "public.history" Column | Type | Collation | Nullable | Default --------+--------+-----------+----------+--------- uid | text | | not null | vid | text | | not null | ts | bigint | | not null | Indexes: "history_pkey" PRIMARY KEY, btree (uid, vid) "history_ts" btree (ts) 删除语句 delete from history where (uid, vid) in (select uid, vid from history where ts <= $1 limit 500) 问题出现 任务稳定运行了一年多的时间，突然有一天线上日志出现了大量的超时报错，排查后发现是pg执行删除语句的时候超过了最大时限 pq: canceling statement due to user request'><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"http://localhost:1313/posts/"},{"@type":"ListItem","position":2,"name":"Postgres 批量删除语句超时","item":"http://localhost:1313/posts/postgres/pg_timeout/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Postgres 批量删除语句超时","name":"Postgres 批量删除语句超时","description":"Postgres 批量删除语句超时 场景 播放记录表history中大约有将近10亿条数据，为了减少内存占用，后台任务以每秒一次的速度删除超过1年未更新的旧记录。\n表结构（示意结构） Table \u0026#34;public.history\u0026#34; Column | Type | Collation | Nullable | Default --------+--------+-----------+----------+--------- uid | text | | not null | vid | text | | not null | ts | bigint | | not null | Indexes: \u0026#34;history_pkey\u0026#34; PRIMARY KEY, btree (uid, vid) \u0026#34;history_ts\u0026#34; btree (ts) 删除语句 delete from history where (uid, vid) in (select uid, vid from history where ts \u0026lt;= $1 limit 500) 问题出现 任务稳定运行了一年多的时间，突然有一天线上日志出现了大量的超时报错，排查后发现是pg执行删除语句的时候超过了最大时限 pq: canceling statement due to user request","keywords":["postgres","优化器","索引"],"articleBody":"Postgres 批量删除语句超时 场景 播放记录表history中大约有将近10亿条数据，为了减少内存占用，后台任务以每秒一次的速度删除超过1年未更新的旧记录。\n表结构（示意结构） Table \"public.history\" Column | Type | Collation | Nullable | Default --------+--------+-----------+----------+--------- uid | text | | not null | vid | text | | not null | ts | bigint | | not null | Indexes: \"history_pkey\" PRIMARY KEY, btree (uid, vid) \"history_ts\" btree (ts) 删除语句 delete from history where (uid, vid) in (select uid, vid from history where ts \u003c= $1 limit 500) 问题出现 任务稳定运行了一年多的时间，突然有一天线上日志出现了大量的超时报错，排查后发现是pg执行删除语句的时候超过了最大时限 pq: canceling statement due to user request\n问题排查 分析语句执行计划 EXPLAIN ANALYZE statement查看该语句的执行情况，发现长时间无响应，缩小limit数量重试，得到：\nQUERY PLAN ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ Delete on history (cost=32.45..119.05 rows=83 width=87) (actual time=3791.173..3791.175 rows=0 loops=1) -\u003e Nested Loop (cost=32.45..119.05 rows=83 width=87) (actual time=3774.474..3789.531 rows=10 loops=1) -\u003e HashAggregate (cost=31.75..31.85 rows=10 width=138) (actual time=3771.885..3771.904 rows=10 loops=1) Group Key: \"ANY_subquery\".uid, \"ANY_subquery\".vid Batches: 1 Memory Usage: 24kB -\u003e Subquery Scan on \"ANY_subquery\" (cost=0.00..31.70 rows=10 width=138) (actual time=103.109..3771.850 rows=10 loops=1) -\u003e Limit (cost=0.00..31.60 rows=10 width=57) (actual time=103.104..3771.828 rows=10 loops=1) -\u003e Seq Scan on history history_1 (cost=0.00..48477444.80 rows=15343146 width=57) (actual time=103.103..3771.821 rows=10 loops=1) Filter: (ts \u003c= '1678603902000'::bigint) Rows Removed by Filter: 6974992 -\u003e Index Scan using history_pkey on history (cost=0.70..8.72 rows=1 width=63) (actual time=1.757..1.757 rows=1 loops=10) Index Cond: ((uid = \"ANY_subquery\".uid) AND (vid = \"ANY_subquery\".vid)) Planning Time: 0.376 ms Execution Time: 3791.369 ms (14 行记录) 发现主要阻塞在子查询，优化器竟然选择了Seq Scan顺序扫描，大量不符合条件的数据被Filter筛掉，时间就耗在这个上边了。\n啊？ts上不是有索引么，这么大的表竟然选择了顺序扫描？\n问一下GPT:顺序和索引扫描是如何取舍的？ 在PostgreSQL中，即使在选择相关列上存在索引，查询计划也可能选择顺序扫描（Sequential Scan）而不是索引扫描（Index Scan）。这是因为查询优化器需要基于多种因素做出决策，如预计的查询代价，表大小，数据的分布等。以下是一些可能的原因：\n全表扫描优于索引扫描：倘若你要查询的数据占据了表的大部分，顺序扫描可能更有效。PostgreSQL查询优化器会权衡全表扫描和索引扫描的代价，如果全表扫描的预计代价更低，那么它可能会选择全表扫描。\n统计信息不准确：PostgreSQL的查询优化器基于统计信息对查询计划进行优化。如果表的统计信息不准确（例如，表数据已经发生了大幅度变化但是没有重新收集统计信息），查询优化器可能会做出错误的决策，即使索引扫描更高效，也可能选择顺序扫描。\n索引列的选择性不高：如果索引列的值重复度很高（例如，性别、是否启用等值只有几种的列），那么使用索引扫描的效率可能并不高，查询优化器可能会选择顺序扫描。\n系统参数设置的问题：某些PostgreSQL系统参数可能影响到索引的使用，比如enable_seqscan参数控制了是否优先使用顺序扫描。\n如果你注意到了查询计划中一直使用序列扫描而不是索引扫描，且索引扫描明显更高效，你可能需要重新收集统计信息（使用ANALYZE命令），或者检查你的查询是否能够有效的利用索引，或者审查并调整相关的系统参数。\n逐一排查 全表扫描优于索引扫描？不确定。全表10亿条数据，全表扫描会比索引扫描更高效么？\n统计信息不准确？不确定。\n索引列的选择性不高？不太可能🙅。ts是按照观看时间排序的，不存在重复度很高的情况。\n系统参数设置的问题？不太可能🙅。任务正常运行一段时间了。\nps：EXPLAIN中cost代表查询优化器估算的查询代价，原因一关于全表扫描和索引扫描的取舍就取决于优化器对两种扫描方式的代价估算，而估算则需要参考原因二提到的统计信息，也就是说一二是相关的。\n有索引但不走的情况有哪些？ 表很小（100行以内），顺序扫描的效率可能会高于索引扫描。\n返回结果占总表很大比例。\n当LIMIT数量很小时，优化器可能会认为“顺序扫描直到结果达到限制数量后终止”会更快的找到结果；但这是双刃剑，依赖于表统计数据的准确性。\n优化器参考的统计信息有哪些？ 表的大小：一般来说，对于非常小的表，顺序扫描往往更有效，因为索引扫描涉及到查找索引并获取磁盘上数据的过程，这对于小表来说可能比直接顺序扫描更耗时。相反，对于大表，索引扫描往往能显著提高效率。\n索引的选择性：索引的选择性是指通过索引能够区分的记录的百分比。如果索引的选择性较高（例如，主键索引），邐那么索引扫描往往更有效。\n查询的选择度：如果查询过滤大部分数据，那么索引扫描对于性能的提升更明显。因为顺序扫描需要扫描整个表，而索引扫描只需要访问满足条件的索引项和相关记录。\n硬件性能：硬件的 IO 性能和 CPU 性能也会影响扫描方式的选择。IO 密集的工作负载可能更适合使用索引扫描，而 CPU 密集的工作负载可能更适合使用顺序扫描。\n索引和表的物理顺序：如果表的物理顺序与索引的顺序高度相关（correlation 接近 1），那么使用索引扫描的成本可能降低，因为顺序 IO 往往比随机 IO 更高效。\n问题定位 通过排查可以猜测：是优化器在执行查询命令时，对代价估算出现了错误，导致选择了实际性能更差的全表扫描方法。\n横向对比其他表 除了history表之外，数据库中还有两个结构相似、数据量相似、索引设置相似的记录表history_a,history_b（简称a表b表），其中a表和history一样在执行后台删除任务，b表没有执行过删除任务。\n浅看一眼表内总行数：\nx=\u003e SELECT relname, reltuples FROM pg_class r JOIN pg_namespace n ON (relnamespace = n.oid) WHERE relkind = 'r' AND n.nspname = 'public'; relname | reltuples -------------------+--------------- history_a | 7.233728e+08 history | 9.3278854e+08 history_b | 8.412001e+08 对history、a、b分别执行查询命令：\nx=\u003e explain analyze select uid, vid from history_a where ts \u003c= 1678692987000 limit 100; QUERY PLAN ---------------------------------------------------------------------------------------------------------------------------------------------------------- Limit (cost=0.57..329.24 rows=100 width=57) (actual time=0.074..11.583 rows=100 loops=1) -\u003e Index Scan using history_a_ts_1 on history_a (cost=0.57..49428562.93 rows=15039219 width=57) (actual time=0.073..11.573 rows=100 loops=1) Index Cond: (ts \u003c= '1678692987000'::bigint) Planning Time: 1.400 ms Execution Time: 11.617 ms (5 行记录) x=\u003e explain analyze select uid, vid from history where ts \u003c= 1678692987000 limit 100; QUERY PLAN ----------------------------------------------------------------------------------------------------------------------------------------- Limit (cost=0.00..262.93 rows=100 width=57) (actual time=519.878..14138.338 rows=100 loops=1) -\u003e Seq Scan on history (cost=0.00..48477444.80 rows=18437250 width=57) (actual time=519.877..14138.275 rows=100 loops=1) Filter: (ts \u003c= '1678692987000'::bigint) Rows Removed by Filter: 24919480 Planning Time: 0.671 ms Execution Time: 14138.486 ms (6 行记录) x=\u003e explain analyze select uid, vid from history_b where ts \u003c= 1678692987000 limit 100; QUERY PLAN ----------------------------------------------------------------------------------------------------------------------------------------------- Limit (cost=0.00..14.53 rows=100 width=77) (actual time=2.032..12.098 rows=100 loops=1) -\u003e Seq Scan on history_b (cost=0.00..42239628.56 rows=290642848 width=77) (actual time=2.031..12.085 rows=100 loops=1) Filter: (ts \u003c= '1678692987000'::bigint) Rows Removed by Filter: 1033 Planning Time: 0.610 ms Execution Time: 15.866 ms (6 行记录) 好奇怪，发现a表选择了索引扫描，b和history表都是顺序扫描，但是b表执行速度显著快于history表。 纵向对比自己 x=\u003e explain analyze select uid, vid from history where ts \u003c= 1678763273000 limit 500; QUERY PLAN --------------------------------------------------------------------------------------------------------------------------------------- Limit (cost=0.00..1166.31 rows=500 width=57) (actual time=10.661..7664.132 rows=500 loops=1) -\u003e Seq Scan on history (cost=0.00..48421139.20 rows=20758242 width=57) (actual time=10.660..7663.903 rows=500 loops=1) Filter: (ts \u003c= '1678763273000'::bigint) Rows Removed by Filter: 14947898 Planning Time: 0.056 ms Execution Time: 7666.074 ms (6 行记录) x=\u003e explain analyze select uid, vid from history where ts \u003c= 1678763273000 order by ts limit 500; QUERY PLAN -------------------------------------------------------------------------------------------------------------------------------------------------------------------- Limit (cost=0.57..1595.46 rows=500 width=65) (actual time=1.700..64.891 rows=500 loops=1) -\u003e Index Scan using history_ts_1 on history (cost=0.57..66214154.35 rows=20758242 width=65) (actual time=1.699..64.824 rows=500 loops=1) Index Cond: (ts \u003c= '1678763273000'::bigint) Planning Time: 0.053 ms Execution Time: 64.949 ms (5 行记录) 添加了order by强制命令走索引，发现走索引的估算cost比顺序扫描的估算cost要低，说明了优化器为什么会选择顺序扫描。同样也说明估算出现了问题。 猜想 批量删除导致了顺序扫描耗时增加，可能和频繁删除插入导致磁盘物理顺序乱序有关，因此在遍历时需要访问更多的内存页。 优化器在history表上决策执行计划时参考的统计数据有问题，导致代价估算出现偏差，可能的原因是没有及时更新统计数据。 验证 查询history表和a表的状态信息表，查看最后执行vacuum和analyze的时间。\nx=\u003e select relname,last_analyze,last_autoanalyze,last_autovacuum from pg_stat_user_tables where relname='history_a' or relname='history'; -[ RECORD 1 ]----+------------------------------ relname | history_a last_analyze | last_autoanalyze | 2024-03-13 07:05:50.585392+00 last_autovacuum | 2024-03-11 13:13:25.05856+00 -[ RECORD 2 ]----+------------------------------ relname | history last_analyze | last_autoanalyze | last_autovacuum | 2024-03-13 16:54:04.673357+00 history表竟然没有配置auto analyze。。。。。。（b表也没配） 问题解决 手动执行 ANALYZE analyze history会以采样的方式对表统计数据进行估算，所以速度相对较快；并且只会阻塞如 vacuum、创建索引、reindex、alter table等命令，不会影响表的读写。\n重新执行命令 x=\u003e explain analyze select uid, vid from history where ts \u003c= 1678795619000 limit 500; QUERY PLAN ----------------------------------------------------------------------------------------------------------------------------------------------------------------- Limit (cost=0.57..1978.10 rows=500 width=57) (actual time=11.670..16.685 rows=500 loops=1) -\u003e Index Scan using history_ts_1 on history (cost=0.57..495456.97 rows=125272 width=57) (actual time=11.669..16.638 rows=500 loops=1) Index Cond: (ts \u003c= '1678795619000'::bigint) Planning Time: 11.769 ms Execution Time: 17.972 ms (5 行记录) 问题解决。\n此外，还可以修改limit值观察一下是不是当limit很小时会顺序查询：\nx=\u003e explain analyze select uid, vid from history where ts \u003c= 1710418557000 limit 1; QUERY PLAN ---------------------------------------------------------------------------------------------------------------------------------- Limit (cost=0.00..0.05 rows=1 width=57) (actual time=1.055..1.056 rows=1 loops=1) -\u003e Seq Scan on history (cost=0.00..48494915.20 rows=924846115 width=57) (actual time=1.054..1.054 rows=1 loops=1) Filter: (ts \u003c= '1710418557000'::bigint) Planning Time: 6.117 ms Execution Time: 1.076 ms (5 行记录) 果然如此。\n索引优化 在寻找问题的过程中，发现索引内存占用较大，可能与数据频繁的删除新增有关，称之为索引膨胀\n查询数据库中所有表的大小：\nSELECT table_name, pg_size_pretty(table_size) AS table_size, pg_size_pretty(indexes_size) AS indexes_size, pg_size_pretty(total_size) AS total_size FROM ( SELECT table_name, pg_table_size(table_name) AS table_size, pg_indexes_size(table_name) AS indexes_size, pg_total_relation_size(table_name) AS total_size FROM ( SELECT ('\"' || table_schema || '\".\"' || table_name || '\"') AS table_name FROM information_schema.tables where table_schema = 'public' ) AS all_tables ORDER BY total_size DESC ) AS pretty_sizes; reindex:\nREINDEX TABLE CONCURRENTLY history; 或者手动\nCREATE INDEX CONCURRENTLY history_ts_1 ON history(ts); DROP INDEX CONCURRENTLY history_ts; CREATE UNIQUE INDEX CONCURRENTLY history_pkey_new ON history(uid, vid); ALTER TABLE history DROP CONSTRAINT history_pkey, ADD CONSTRAINT history_pkey PRIMARY KEY USING INDEX history_pkey_new; ","wordCount":"825","inLanguage":"zh","datePublished":"2024-03-16T17:26:22+08:00","dateModified":"2024-03-16T17:26:22+08:00","author":{"@type":"Person","name":"sweetpear"},"mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:1313/posts/postgres/pg_timeout/"},"publisher":{"@type":"Organization","name":"Sweetpear's Blog","logo":{"@type":"ImageObject","url":"http://localhost:1313/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://localhost:1313/ accesskey=h title="Sweetpear's Blog (Alt + H)">Sweetpear's Blog</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=http://localhost:1313/archives/ title=归档><span>归档</span></a></li><li><a href=http://localhost:1313/tags/ title=标签><span>标签</span></a></li><li><a href=http://localhost:1313/search/ title="搜索 (Alt + /)" accesskey=/><span>搜索</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=http://localhost:1313/>主页</a>&nbsp;»&nbsp;<a href=http://localhost:1313/posts/>Posts</a></div><h1 class="post-title entry-hint-parent">Postgres 批量删除语句超时</h1><div class=post-meta><span title='2024-03-16 17:26:22 +0800 CST'>2024-03-16</span>&nbsp;·&nbsp;sweetpear&nbsp;|&nbsp;<a href=https://github.com/sweetpear0108/blog/tree/main/content/posts/postgres/pg_timeout.md rel="noopener noreferrer" target=_blank>修改建议</a></div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><span class=details>目录</span></summary><div class=inner><nav id=TableOfContents><ul><li><a href=#场景>场景</a></li><li><a href=#问题出现>问题出现</a></li><li><a href=#问题排查>问题排查</a><ul><li><a href=#分析语句执行计划>分析语句执行计划</a></li><li><a href=#问一下gpt顺序和索引扫描是如何取舍的>问一下GPT:顺序和索引扫描是如何取舍的？</a></li><li><a href=#逐一排查>逐一排查</a></li><li><a href=#有索引但不走的情况有哪些>有索引但不走的情况有哪些？</a></li><li><a href=#优化器参考的统计信息有哪些>优化器参考的统计信息有哪些？</a></li></ul></li><li><a href=#问题定位>问题定位</a><ul><li><a href=#横向对比其他表>横向对比其他表</a></li><li><a href=#纵向对比自己>纵向对比自己</a></li><li><a href=#猜想>猜想</a></li><li><a href=#验证>验证</a></li></ul></li><li><a href=#问题解决>问题解决</a><ul><li><a href=#手动执行-analyze>手动执行 ANALYZE</a></li><li><a href=#重新执行命令>重新执行命令</a></li></ul></li><li><a href=#索引优化>索引优化</a></li></ul></nav></div></details></div><div class=post-content><h1 id=postgres-批量删除语句超时>Postgres 批量删除语句超时<a hidden class=anchor aria-hidden=true href=#postgres-批量删除语句超时>#</a></h1><h2 id=场景>场景<a hidden class=anchor aria-hidden=true href=#场景>#</a></h2><p>播放记录表<code>history</code>中大约有将近10亿条数据，为了减少内存占用，后台任务以每秒一次的速度删除超过1年未更新的旧记录。</p><ul><li>表结构（示意结构）</li></ul><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=w>        </span><span class=k>Table</span><span class=w> </span><span class=s2>&#34;public.history&#34;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=k>Column</span><span class=w> </span><span class=o>|</span><span class=w>  </span><span class=k>Type</span><span class=w>  </span><span class=o>|</span><span class=w> </span><span class=k>Collation</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=k>Nullable</span><span class=w> </span><span class=o>|</span><span class=w> </span><span class=k>Default</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=c1>--------+--------+-----------+----------+---------
</span></span></span><span class=line><span class=cl><span class=c1></span><span class=w> </span><span class=n>uid</span><span class=w>    </span><span class=o>|</span><span class=w> </span><span class=nb>text</span><span class=w>   </span><span class=o>|</span><span class=w>           </span><span class=o>|</span><span class=w> </span><span class=k>not</span><span class=w> </span><span class=k>null</span><span class=w> </span><span class=o>|</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=n>vid</span><span class=w>    </span><span class=o>|</span><span class=w> </span><span class=nb>text</span><span class=w>   </span><span class=o>|</span><span class=w>           </span><span class=o>|</span><span class=w> </span><span class=k>not</span><span class=w> </span><span class=k>null</span><span class=w> </span><span class=o>|</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w> </span><span class=n>ts</span><span class=w>     </span><span class=o>|</span><span class=w> </span><span class=nb>bigint</span><span class=w> </span><span class=o>|</span><span class=w>           </span><span class=o>|</span><span class=w> </span><span class=k>not</span><span class=w> </span><span class=k>null</span><span class=w> </span><span class=o>|</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=n>Indexes</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s2>&#34;history_pkey&#34;</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=p>,</span><span class=w> </span><span class=n>btree</span><span class=w> </span><span class=p>(</span><span class=n>uid</span><span class=p>,</span><span class=w> </span><span class=n>vid</span><span class=p>)</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=s2>&#34;history_ts&#34;</span><span class=w> </span><span class=n>btree</span><span class=w> </span><span class=p>(</span><span class=n>ts</span><span class=p>)</span><span class=w>
</span></span></span></code></pre></div><ul><li>删除语句
<code>delete from history where (uid, vid) in (select uid, vid from history where ts &lt;= $1 limit 500)</code></li></ul><h2 id=问题出现>问题出现<a hidden class=anchor aria-hidden=true href=#问题出现>#</a></h2><p>任务稳定运行了一年多的时间，突然有一天线上日志出现了大量的超时报错，排查后发现是pg执行删除语句的时候超过了最大时限 <code>pq: canceling statement due to user request</code></p><h2 id=问题排查>问题排查<a hidden class=anchor aria-hidden=true href=#问题排查>#</a></h2><h3 id=分析语句执行计划>分析语句执行计划<a hidden class=anchor aria-hidden=true href=#分析语句执行计划>#</a></h3><p><code>EXPLAIN ANALYZE statement</code>查看该语句的执行情况，发现长时间无响应，缩小<code>limit</code>数量重试，得到：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>                                                                                     QUERY PLAN
</span></span><span class=line><span class=cl>------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class=line><span class=cl> Delete on <span class=nb>history</span>  <span class=o>(</span><span class=nv>cost</span><span class=o>=</span>32.45..119.05 <span class=nv>rows</span><span class=o>=</span><span class=m>83</span> <span class=nv>width</span><span class=o>=</span>87<span class=o>)</span> <span class=o>(</span>actual <span class=nv>time</span><span class=o>=</span>3791.173..3791.175 <span class=nv>rows</span><span class=o>=</span><span class=m>0</span> <span class=nv>loops</span><span class=o>=</span>1<span class=o>)</span>
</span></span><span class=line><span class=cl>   -&gt;  Nested Loop  <span class=o>(</span><span class=nv>cost</span><span class=o>=</span>32.45..119.05 <span class=nv>rows</span><span class=o>=</span><span class=m>83</span> <span class=nv>width</span><span class=o>=</span>87<span class=o>)</span> <span class=o>(</span>actual <span class=nv>time</span><span class=o>=</span>3774.474..3789.531 <span class=nv>rows</span><span class=o>=</span><span class=m>10</span> <span class=nv>loops</span><span class=o>=</span>1<span class=o>)</span>
</span></span><span class=line><span class=cl>         -&gt;  HashAggregate  <span class=o>(</span><span class=nv>cost</span><span class=o>=</span>31.75..31.85 <span class=nv>rows</span><span class=o>=</span><span class=m>10</span> <span class=nv>width</span><span class=o>=</span>138<span class=o>)</span> <span class=o>(</span>actual <span class=nv>time</span><span class=o>=</span>3771.885..3771.904 <span class=nv>rows</span><span class=o>=</span><span class=m>10</span> <span class=nv>loops</span><span class=o>=</span>1<span class=o>)</span>
</span></span><span class=line><span class=cl>               Group Key: <span class=s2>&#34;ANY_subquery&#34;</span>.uid, <span class=s2>&#34;ANY_subquery&#34;</span>.vid
</span></span><span class=line><span class=cl>               Batches: <span class=m>1</span>  Memory Usage: 24kB
</span></span><span class=line><span class=cl>               -&gt;  Subquery Scan on <span class=s2>&#34;ANY_subquery&#34;</span>  <span class=o>(</span><span class=nv>cost</span><span class=o>=</span>0.00..31.70 <span class=nv>rows</span><span class=o>=</span><span class=m>10</span> <span class=nv>width</span><span class=o>=</span>138<span class=o>)</span> <span class=o>(</span>actual <span class=nv>time</span><span class=o>=</span>103.109..3771.850 <span class=nv>rows</span><span class=o>=</span><span class=m>10</span> <span class=nv>loops</span><span class=o>=</span>1<span class=o>)</span>
</span></span><span class=line><span class=cl>                     -&gt;  Limit  <span class=o>(</span><span class=nv>cost</span><span class=o>=</span>0.00..31.60 <span class=nv>rows</span><span class=o>=</span><span class=m>10</span> <span class=nv>width</span><span class=o>=</span>57<span class=o>)</span> <span class=o>(</span>actual <span class=nv>time</span><span class=o>=</span>103.104..3771.828 <span class=nv>rows</span><span class=o>=</span><span class=m>10</span> <span class=nv>loops</span><span class=o>=</span>1<span class=o>)</span>
</span></span><span class=line><span class=cl>                           -&gt;  Seq Scan on <span class=nb>history</span> history_1  <span class=o>(</span><span class=nv>cost</span><span class=o>=</span>0.00..48477444.80 <span class=nv>rows</span><span class=o>=</span><span class=m>15343146</span> <span class=nv>width</span><span class=o>=</span>57<span class=o>)</span> <span class=o>(</span>actual <span class=nv>time</span><span class=o>=</span>103.103..3771.821 <span class=nv>rows</span><span class=o>=</span><span class=m>10</span> <span class=nv>loops</span><span class=o>=</span>1<span class=o>)</span>
</span></span><span class=line><span class=cl>                                 Filter: <span class=o>(</span>ts &lt;<span class=o>=</span> <span class=s1>&#39;1678603902000&#39;</span>::bigint<span class=o>)</span>
</span></span><span class=line><span class=cl>                                 Rows Removed by Filter: <span class=m>6974992</span>
</span></span><span class=line><span class=cl>         -&gt;  Index Scan using history_pkey on <span class=nb>history</span>  <span class=o>(</span><span class=nv>cost</span><span class=o>=</span>0.70..8.72 <span class=nv>rows</span><span class=o>=</span><span class=m>1</span> <span class=nv>width</span><span class=o>=</span>63<span class=o>)</span> <span class=o>(</span>actual <span class=nv>time</span><span class=o>=</span>1.757..1.757 <span class=nv>rows</span><span class=o>=</span><span class=m>1</span> <span class=nv>loops</span><span class=o>=</span>10<span class=o>)</span>
</span></span><span class=line><span class=cl>               Index Cond: <span class=o>((</span><span class=nv>uid</span> <span class=o>=</span> <span class=s2>&#34;ANY_subquery&#34;</span>.uid<span class=o>)</span> AND <span class=o>(</span><span class=nv>vid</span> <span class=o>=</span> <span class=s2>&#34;ANY_subquery&#34;</span>.vid<span class=o>))</span>
</span></span><span class=line><span class=cl> Planning Time: 0.376 ms
</span></span><span class=line><span class=cl> Execution Time: 3791.369 ms
</span></span><span class=line><span class=cl><span class=o>(</span><span class=m>14</span> 行记录<span class=o>)</span>
</span></span></code></pre></div><p>发现主要阻塞在子查询，优化器竟然选择了<code>Seq Scan</code>顺序扫描，大量不符合条件的数据被<code>Filter</code>筛掉，时间就耗在这个上边了。</p><p><code>啊？ts上不是有索引么，这么大的表竟然选择了顺序扫描？</code></p><h3 id=问一下gpt顺序和索引扫描是如何取舍的>问一下GPT:顺序和索引扫描是如何取舍的？<a hidden class=anchor aria-hidden=true href=#问一下gpt顺序和索引扫描是如何取舍的>#</a></h3><p>在PostgreSQL中，即使在选择相关列上存在索引，查询计划也可能选择顺序扫描（Sequential Scan）而不是索引扫描（Index Scan）。这是因为查询优化器需要基于多种因素做出决策，如预计的查询代价，表大小，数据的分布等。以下是一些可能的原因：</p><ol><li><p><strong>全表扫描优于索引扫描</strong>：倘若你要查询的数据占据了表的大部分，顺序扫描可能更有效。PostgreSQL查询优化器会权衡全表扫描和索引扫描的代价，如果全表扫描的预计代价更低，那么它可能会选择全表扫描。</p></li><li><p><strong>统计信息不准确</strong>：PostgreSQL的查询优化器基于统计信息对查询计划进行优化。如果表的统计信息不准确（例如，表数据已经发生了大幅度变化但是没有重新收集统计信息），查询优化器可能会做出错误的决策，即使索引扫描更高效，也可能选择顺序扫描。</p></li><li><p><strong>索引列的选择性不高</strong>：如果索引列的值重复度很高（例如，性别、是否启用等值只有几种的列），那么使用索引扫描的效率可能并不高，查询优化器可能会选择顺序扫描。</p></li><li><p><strong>系统参数设置的问题</strong>：某些PostgreSQL系统参数可能影响到索引的使用，比如<code>enable_seqscan</code>参数控制了是否优先使用顺序扫描。</p></li></ol><p>如果你注意到了查询计划中一直使用序列扫描而不是索引扫描，且索引扫描明显更高效，你可能需要重新收集统计信息（使用<code>ANALYZE</code>命令），或者检查你的查询是否能够有效的利用索引，或者审查并调整相关的系统参数。</p><h3 id=逐一排查>逐一排查<a hidden class=anchor aria-hidden=true href=#逐一排查>#</a></h3><ol><li><p>全表扫描优于索引扫描？不确定。全表10亿条数据，全表扫描会比索引扫描更高效么？</p></li><li><p>统计信息不准确？不确定。</p></li><li><p>索引列的选择性不高？不太可能🙅。ts是按照观看时间排序的，不存在重复度很高的情况。</p></li><li><p>系统参数设置的问题？不太可能🙅。任务正常运行一段时间了。</p></li></ol><p>ps：<code>EXPLAIN</code>中cost代表查询优化器估算的查询代价，原因一关于全表扫描和索引扫描的取舍就取决于优化器对两种扫描方式的<strong>代价估算</strong>，而估算则需要参考原因二提到的<strong>统计信息</strong>，也就是说一二是相关的。</p><h3 id=有索引但不走的情况有哪些>有索引但不走的情况有哪些？<a hidden class=anchor aria-hidden=true href=#有索引但不走的情况有哪些>#</a></h3><ol><li><p>表很小（100行以内），顺序扫描的效率可能会高于索引扫描。</p></li><li><p>返回结果占总表很大比例。</p></li><li><p>当<code>LIMIT</code>数量很小时，优化器可能会认为“顺序扫描直到结果达到限制数量后终止”会更快的找到结果；但这是<strong>双刃剑</strong>，依赖于表统计数据的准确性。</p></li></ol><h3 id=优化器参考的统计信息有哪些>优化器参考的统计信息有哪些？<a hidden class=anchor aria-hidden=true href=#优化器参考的统计信息有哪些>#</a></h3><ol><li><p><strong>表的大小</strong>：一般来说，对于非常小的表，顺序扫描往往更有效，因为索引扫描涉及到查找索引并获取磁盘上数据的过程，这对于小表来说可能比直接顺序扫描更耗时。相反，对于大表，索引扫描往往能显著提高效率。</p></li><li><p><strong>索引的选择性</strong>：索引的选择性是指通过索引能够区分的记录的百分比。如果索引的选择性较高（例如，主键索引），邐那么索引扫描往往更有效。</p></li><li><p><strong>查询的选择度</strong>：如果查询过滤大部分数据，那么索引扫描对于性能的提升更明显。因为顺序扫描需要扫描整个表，而索引扫描只需要访问满足条件的索引项和相关记录。</p></li><li><p><strong>硬件性能</strong>：硬件的 IO 性能和 CPU 性能也会影响扫描方式的选择。IO 密集的工作负载可能更适合使用索引扫描，而 CPU 密集的工作负载可能更适合使用顺序扫描。</p></li><li><p><strong>索引和表的物理顺序</strong>：如果表的物理顺序与索引的顺序高度相关（correlation 接近 1），那么使用索引扫描的成本可能降低，因为顺序 IO 往往比随机 IO 更高效。</p></li></ol><h2 id=问题定位>问题定位<a hidden class=anchor aria-hidden=true href=#问题定位>#</a></h2><p>通过排查可以猜测：是优化器在执行查询命令时，对代价估算出现了错误，导致选择了实际性能更差的全表扫描方法。</p><h3 id=横向对比其他表>横向对比其他表<a hidden class=anchor aria-hidden=true href=#横向对比其他表>#</a></h3><p>除了<code>history</code>表之外，数据库中还有两个结构相似、数据量相似、索引设置相似的记录表<code>history_a</code>,<code>history_b</code>（简称a表b表），其中a表和history一样在执行后台删除任务，b表没有执行过删除任务。</p><p>浅看一眼表内总行数：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>x</span><span class=o>=</span>&gt; SELECT relname, reltuples FROM pg_class r JOIN pg_namespace n ON <span class=o>(</span><span class=nv>relnamespace</span> <span class=o>=</span> n.oid<span class=o>)</span> WHERE <span class=nv>relkind</span> <span class=o>=</span> <span class=s1>&#39;r&#39;</span> AND n.nspname <span class=o>=</span> <span class=s1>&#39;public&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>       relname     <span class=p>|</span>   reltuples
</span></span><span class=line><span class=cl>-------------------+---------------
</span></span><span class=line><span class=cl> history_a         <span class=p>|</span>  7.233728e+08
</span></span><span class=line><span class=cl> <span class=nb>history</span>           <span class=p>|</span> 9.3278854e+08
</span></span><span class=line><span class=cl> history_b         <span class=p>|</span>  8.412001e+08
</span></span></code></pre></div><p>对history、a、b分别执行查询命令：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>x</span><span class=o>=</span>&gt; explain analyze <span class=k>select</span> uid, vid from history_a where ts &lt;<span class=o>=</span> <span class=m>1678692987000</span> limit 100<span class=p>;</span>
</span></span><span class=line><span class=cl>                                                                        QUERY PLAN
</span></span><span class=line><span class=cl>----------------------------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class=line><span class=cl> Limit  <span class=o>(</span><span class=nv>cost</span><span class=o>=</span>0.57..329.24 <span class=nv>rows</span><span class=o>=</span><span class=m>100</span> <span class=nv>width</span><span class=o>=</span>57<span class=o>)</span> <span class=o>(</span>actual <span class=nv>time</span><span class=o>=</span>0.074..11.583 <span class=nv>rows</span><span class=o>=</span><span class=m>100</span> <span class=nv>loops</span><span class=o>=</span>1<span class=o>)</span>
</span></span><span class=line><span class=cl>   -&gt;  Index Scan using history_a_ts_1 on history_a  <span class=o>(</span><span class=nv>cost</span><span class=o>=</span>0.57..49428562.93 <span class=nv>rows</span><span class=o>=</span><span class=m>15039219</span> <span class=nv>width</span><span class=o>=</span>57<span class=o>)</span> <span class=o>(</span>actual <span class=nv>time</span><span class=o>=</span>0.073..11.573 <span class=nv>rows</span><span class=o>=</span><span class=m>100</span> <span class=nv>loops</span><span class=o>=</span>1<span class=o>)</span>
</span></span><span class=line><span class=cl>         Index Cond: <span class=o>(</span>ts &lt;<span class=o>=</span> <span class=s1>&#39;1678692987000&#39;</span>::bigint<span class=o>)</span>
</span></span><span class=line><span class=cl> Planning Time: 1.400 ms
</span></span><span class=line><span class=cl> Execution Time: 11.617 ms
</span></span><span class=line><span class=cl><span class=o>(</span><span class=m>5</span> 行记录<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>x</span><span class=o>=</span>&gt; explain analyze <span class=k>select</span> uid, vid from <span class=nb>history</span> where ts &lt;<span class=o>=</span> <span class=m>1678692987000</span> limit 100<span class=p>;</span>
</span></span><span class=line><span class=cl>                                                               QUERY PLAN
</span></span><span class=line><span class=cl>-----------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class=line><span class=cl> Limit  <span class=o>(</span><span class=nv>cost</span><span class=o>=</span>0.00..262.93 <span class=nv>rows</span><span class=o>=</span><span class=m>100</span> <span class=nv>width</span><span class=o>=</span>57<span class=o>)</span> <span class=o>(</span>actual <span class=nv>time</span><span class=o>=</span>519.878..14138.338 <span class=nv>rows</span><span class=o>=</span><span class=m>100</span> <span class=nv>loops</span><span class=o>=</span>1<span class=o>)</span>
</span></span><span class=line><span class=cl>   -&gt;  Seq Scan on <span class=nb>history</span>  <span class=o>(</span><span class=nv>cost</span><span class=o>=</span>0.00..48477444.80 <span class=nv>rows</span><span class=o>=</span><span class=m>18437250</span> <span class=nv>width</span><span class=o>=</span>57<span class=o>)</span> <span class=o>(</span>actual <span class=nv>time</span><span class=o>=</span>519.877..14138.275 <span class=nv>rows</span><span class=o>=</span><span class=m>100</span> <span class=nv>loops</span><span class=o>=</span>1<span class=o>)</span>
</span></span><span class=line><span class=cl>         Filter: <span class=o>(</span>ts &lt;<span class=o>=</span> <span class=s1>&#39;1678692987000&#39;</span>::bigint<span class=o>)</span>
</span></span><span class=line><span class=cl>         Rows Removed by Filter: <span class=m>24919480</span>
</span></span><span class=line><span class=cl> Planning Time: 0.671 ms
</span></span><span class=line><span class=cl> Execution Time: 14138.486 ms
</span></span><span class=line><span class=cl><span class=o>(</span><span class=m>6</span> 行记录<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>x</span><span class=o>=</span>&gt; explain analyze <span class=k>select</span> uid, vid from history_b where ts &lt;<span class=o>=</span> <span class=m>1678692987000</span> limit 100<span class=p>;</span>
</span></span><span class=line><span class=cl>                                                                  QUERY PLAN
</span></span><span class=line><span class=cl>-----------------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class=line><span class=cl> Limit  <span class=o>(</span><span class=nv>cost</span><span class=o>=</span>0.00..14.53 <span class=nv>rows</span><span class=o>=</span><span class=m>100</span> <span class=nv>width</span><span class=o>=</span>77<span class=o>)</span> <span class=o>(</span>actual <span class=nv>time</span><span class=o>=</span>2.032..12.098 <span class=nv>rows</span><span class=o>=</span><span class=m>100</span> <span class=nv>loops</span><span class=o>=</span>1<span class=o>)</span>
</span></span><span class=line><span class=cl>   -&gt;  Seq Scan on history_b  <span class=o>(</span><span class=nv>cost</span><span class=o>=</span>0.00..42239628.56 <span class=nv>rows</span><span class=o>=</span><span class=m>290642848</span> <span class=nv>width</span><span class=o>=</span>77<span class=o>)</span> <span class=o>(</span>actual <span class=nv>time</span><span class=o>=</span>2.031..12.085 <span class=nv>rows</span><span class=o>=</span><span class=m>100</span> <span class=nv>loops</span><span class=o>=</span>1<span class=o>)</span>
</span></span><span class=line><span class=cl>         Filter: <span class=o>(</span>ts &lt;<span class=o>=</span> <span class=s1>&#39;1678692987000&#39;</span>::bigint<span class=o>)</span>
</span></span><span class=line><span class=cl>         Rows Removed by Filter: <span class=m>1033</span>
</span></span><span class=line><span class=cl> Planning Time: 0.610 ms
</span></span><span class=line><span class=cl> Execution Time: 15.866 ms
</span></span><span class=line><span class=cl><span class=o>(</span><span class=m>6</span> 行记录<span class=o>)</span>
</span></span></code></pre></div><ul><li>好奇怪，发现a表选择了索引扫描，b和history表都是顺序扫描，但是b表执行速度显著快于history表。</li></ul><h3 id=纵向对比自己>纵向对比自己<a hidden class=anchor aria-hidden=true href=#纵向对比自己>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>x</span><span class=o>=</span>&gt; explain analyze <span class=k>select</span> uid, vid from <span class=nb>history</span> where ts &lt;<span class=o>=</span> <span class=m>1678763273000</span> limit 500<span class=p>;</span>
</span></span><span class=line><span class=cl>                                                              QUERY PLAN
</span></span><span class=line><span class=cl>---------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class=line><span class=cl> Limit  <span class=o>(</span><span class=nv>cost</span><span class=o>=</span>0.00..1166.31 <span class=nv>rows</span><span class=o>=</span><span class=m>500</span> <span class=nv>width</span><span class=o>=</span>57<span class=o>)</span> <span class=o>(</span>actual <span class=nv>time</span><span class=o>=</span>10.661..7664.132 <span class=nv>rows</span><span class=o>=</span><span class=m>500</span> <span class=nv>loops</span><span class=o>=</span>1<span class=o>)</span>
</span></span><span class=line><span class=cl>   -&gt;  Seq Scan on <span class=nb>history</span>  <span class=o>(</span><span class=nv>cost</span><span class=o>=</span>0.00..48421139.20 <span class=nv>rows</span><span class=o>=</span><span class=m>20758242</span> <span class=nv>width</span><span class=o>=</span>57<span class=o>)</span> <span class=o>(</span>actual <span class=nv>time</span><span class=o>=</span>10.660..7663.903 <span class=nv>rows</span><span class=o>=</span><span class=m>500</span> <span class=nv>loops</span><span class=o>=</span>1<span class=o>)</span>
</span></span><span class=line><span class=cl>         Filter: <span class=o>(</span>ts &lt;<span class=o>=</span> <span class=s1>&#39;1678763273000&#39;</span>::bigint<span class=o>)</span>
</span></span><span class=line><span class=cl>         Rows Removed by Filter: <span class=m>14947898</span>
</span></span><span class=line><span class=cl> Planning Time: 0.056 ms
</span></span><span class=line><span class=cl> Execution Time: 7666.074 ms
</span></span><span class=line><span class=cl><span class=o>(</span><span class=m>6</span> 行记录<span class=o>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=nv>x</span><span class=o>=</span>&gt; explain analyze <span class=k>select</span> uid, vid from <span class=nb>history</span> where ts &lt;<span class=o>=</span> <span class=m>1678763273000</span> order by ts limit 500<span class=p>;</span>
</span></span><span class=line><span class=cl>                                                                             QUERY PLAN
</span></span><span class=line><span class=cl>--------------------------------------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class=line><span class=cl> Limit  <span class=o>(</span><span class=nv>cost</span><span class=o>=</span>0.57..1595.46 <span class=nv>rows</span><span class=o>=</span><span class=m>500</span> <span class=nv>width</span><span class=o>=</span>65<span class=o>)</span> <span class=o>(</span>actual <span class=nv>time</span><span class=o>=</span>1.700..64.891 <span class=nv>rows</span><span class=o>=</span><span class=m>500</span> <span class=nv>loops</span><span class=o>=</span>1<span class=o>)</span>
</span></span><span class=line><span class=cl>   -&gt;  Index Scan using history_ts_1 on <span class=nb>history</span>  <span class=o>(</span><span class=nv>cost</span><span class=o>=</span>0.57..66214154.35 <span class=nv>rows</span><span class=o>=</span><span class=m>20758242</span> <span class=nv>width</span><span class=o>=</span>65<span class=o>)</span> <span class=o>(</span>actual <span class=nv>time</span><span class=o>=</span>1.699..64.824 <span class=nv>rows</span><span class=o>=</span><span class=m>500</span> <span class=nv>loops</span><span class=o>=</span>1<span class=o>)</span>
</span></span><span class=line><span class=cl>         Index Cond: <span class=o>(</span>ts &lt;<span class=o>=</span> <span class=s1>&#39;1678763273000&#39;</span>::bigint<span class=o>)</span>
</span></span><span class=line><span class=cl> Planning Time: 0.053 ms
</span></span><span class=line><span class=cl> Execution Time: 64.949 ms
</span></span><span class=line><span class=cl><span class=o>(</span><span class=m>5</span> 行记录<span class=o>)</span>
</span></span></code></pre></div><ul><li>添加了<code>order by</code>强制命令走索引，发现走索引的估算cost比顺序扫描的估算cost要低，说明了优化器为什么会选择顺序扫描。同样也说明<strong>估算出现了问题</strong>。</li></ul><h3 id=猜想>猜想<a hidden class=anchor aria-hidden=true href=#猜想>#</a></h3><ol><li>批量删除导致了顺序扫描耗时增加，可能和频繁删除插入导致磁盘物理顺序乱序有关，因此在遍历时需要访问更多的内存页。</li><li>优化器在history表上决策执行计划时<strong>参考的统计数据有问题</strong>，导致代价估算出现偏差，可能的原因是没有及时更新统计数据。</li></ol><h3 id=验证>验证<a hidden class=anchor aria-hidden=true href=#验证>#</a></h3><p>查询history表和a表的状态信息表，查看最后执行<code>vacuum</code>和<code>analyze</code>的时间。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>x</span><span class=o>=</span>&gt; <span class=k>select</span> relname,last_analyze,last_autoanalyze,last_autovacuum from  pg_stat_user_tables where <span class=nv>relname</span><span class=o>=</span><span class=s1>&#39;history_a&#39;</span> or <span class=nv>relname</span><span class=o>=</span><span class=s1>&#39;history&#39;</span><span class=p>;</span>
</span></span><span class=line><span class=cl>-<span class=o>[</span> RECORD <span class=m>1</span> <span class=o>]</span>----+------------------------------
</span></span><span class=line><span class=cl>relname          <span class=p>|</span> history_a
</span></span><span class=line><span class=cl>last_analyze     <span class=p>|</span>
</span></span><span class=line><span class=cl>last_autoanalyze <span class=p>|</span> 2024-03-13 07:05:50.585392+00
</span></span><span class=line><span class=cl>last_autovacuum  <span class=p>|</span> 2024-03-11 13:13:25.05856+00
</span></span><span class=line><span class=cl>-<span class=o>[</span> RECORD <span class=m>2</span> <span class=o>]</span>----+------------------------------
</span></span><span class=line><span class=cl>relname          <span class=p>|</span> <span class=nb>history</span>
</span></span><span class=line><span class=cl>last_analyze     <span class=p>|</span>
</span></span><span class=line><span class=cl>last_autoanalyze <span class=p>|</span>
</span></span><span class=line><span class=cl>last_autovacuum  <span class=p>|</span> 2024-03-13 16:54:04.673357+00
</span></span></code></pre></div><ul><li>history表竟然没有配置<code>auto analyze</code>。。。。。。（b表也没配）</li></ul><h2 id=问题解决>问题解决<a hidden class=anchor aria-hidden=true href=#问题解决>#</a></h2><h3 id=手动执行-analyze>手动执行 ANALYZE<a hidden class=anchor aria-hidden=true href=#手动执行-analyze>#</a></h3><p><code>analyze history</code>会以<strong>采样</strong>的方式对表统计数据进行估算，所以速度相对较快；并且只会阻塞如 vacuum、创建索引、reindex、alter table等命令，<strong>不会影响表的读写</strong>。</p><h3 id=重新执行命令>重新执行命令<a hidden class=anchor aria-hidden=true href=#重新执行命令>#</a></h3><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>x</span><span class=o>=</span>&gt; explain analyze <span class=k>select</span> uid, vid from <span class=nb>history</span> where ts &lt;<span class=o>=</span> <span class=m>1678795619000</span> limit 500<span class=p>;</span>
</span></span><span class=line><span class=cl>                                                                           QUERY PLAN
</span></span><span class=line><span class=cl>-----------------------------------------------------------------------------------------------------------------------------------------------------------------
</span></span><span class=line><span class=cl> Limit  <span class=o>(</span><span class=nv>cost</span><span class=o>=</span>0.57..1978.10 <span class=nv>rows</span><span class=o>=</span><span class=m>500</span> <span class=nv>width</span><span class=o>=</span>57<span class=o>)</span> <span class=o>(</span>actual <span class=nv>time</span><span class=o>=</span>11.670..16.685 <span class=nv>rows</span><span class=o>=</span><span class=m>500</span> <span class=nv>loops</span><span class=o>=</span>1<span class=o>)</span>
</span></span><span class=line><span class=cl>   -&gt;  Index Scan using history_ts_1 on <span class=nb>history</span>  <span class=o>(</span><span class=nv>cost</span><span class=o>=</span>0.57..495456.97 <span class=nv>rows</span><span class=o>=</span><span class=m>125272</span> <span class=nv>width</span><span class=o>=</span>57<span class=o>)</span> <span class=o>(</span>actual <span class=nv>time</span><span class=o>=</span>11.669..16.638 <span class=nv>rows</span><span class=o>=</span><span class=m>500</span> <span class=nv>loops</span><span class=o>=</span>1<span class=o>)</span>
</span></span><span class=line><span class=cl>         Index Cond: <span class=o>(</span>ts &lt;<span class=o>=</span> <span class=s1>&#39;1678795619000&#39;</span>::bigint<span class=o>)</span>
</span></span><span class=line><span class=cl> Planning Time: 11.769 ms
</span></span><span class=line><span class=cl> Execution Time: 17.972 ms
</span></span><span class=line><span class=cl><span class=o>(</span><span class=m>5</span> 行记录<span class=o>)</span>
</span></span></code></pre></div><p><strong>问题解决。</strong></p><p>此外，还可以修改limit值观察一下是不是当limit很小时会顺序查询：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl><span class=nv>x</span><span class=o>=</span>&gt; explain analyze <span class=k>select</span> uid, vid from <span class=nb>history</span> where ts &lt;<span class=o>=</span> <span class=m>1710418557000</span> limit 1<span class=p>;</span>
</span></span><span class=line><span class=cl>                                                            QUERY PLAN
</span></span><span class=line><span class=cl>----------------------------------------------------------------------------------------------------------------------------------
</span></span><span class=line><span class=cl> Limit  <span class=o>(</span><span class=nv>cost</span><span class=o>=</span>0.00..0.05 <span class=nv>rows</span><span class=o>=</span><span class=m>1</span> <span class=nv>width</span><span class=o>=</span>57<span class=o>)</span> <span class=o>(</span>actual <span class=nv>time</span><span class=o>=</span>1.055..1.056 <span class=nv>rows</span><span class=o>=</span><span class=m>1</span> <span class=nv>loops</span><span class=o>=</span>1<span class=o>)</span>
</span></span><span class=line><span class=cl>   -&gt;  Seq Scan on <span class=nb>history</span>  <span class=o>(</span><span class=nv>cost</span><span class=o>=</span>0.00..48494915.20 <span class=nv>rows</span><span class=o>=</span><span class=m>924846115</span> <span class=nv>width</span><span class=o>=</span>57<span class=o>)</span> <span class=o>(</span>actual <span class=nv>time</span><span class=o>=</span>1.054..1.054 <span class=nv>rows</span><span class=o>=</span><span class=m>1</span> <span class=nv>loops</span><span class=o>=</span>1<span class=o>)</span>
</span></span><span class=line><span class=cl>         Filter: <span class=o>(</span>ts &lt;<span class=o>=</span> <span class=s1>&#39;1710418557000&#39;</span>::bigint<span class=o>)</span>
</span></span><span class=line><span class=cl> Planning Time: 6.117 ms
</span></span><span class=line><span class=cl> Execution Time: 1.076 ms
</span></span><span class=line><span class=cl><span class=o>(</span><span class=m>5</span> 行记录<span class=o>)</span>
</span></span></code></pre></div><p>果然如此。</p><h2 id=索引优化>索引优化<a hidden class=anchor aria-hidden=true href=#索引优化>#</a></h2><p>在寻找问题的过程中，发现索引内存占用较大，可能与数据频繁的删除新增有关，称之为<strong>索引膨胀</strong></p><p>查询数据库中所有表的大小：</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>SELECT</span><span class=w> </span><span class=k>table_name</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=n>pg_size_pretty</span><span class=p>(</span><span class=n>table_size</span><span class=p>)</span><span class=w>   </span><span class=k>AS</span><span class=w> </span><span class=n>table_size</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=n>pg_size_pretty</span><span class=p>(</span><span class=n>indexes_size</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>indexes_size</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>       </span><span class=n>pg_size_pretty</span><span class=p>(</span><span class=n>total_size</span><span class=p>)</span><span class=w>   </span><span class=k>AS</span><span class=w> </span><span class=n>total_size</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>FROM</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>         </span><span class=k>SELECT</span><span class=w> </span><span class=k>table_name</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>pg_table_size</span><span class=p>(</span><span class=k>table_name</span><span class=p>)</span><span class=w>          </span><span class=k>AS</span><span class=w> </span><span class=n>table_size</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>pg_indexes_size</span><span class=p>(</span><span class=k>table_name</span><span class=p>)</span><span class=w>        </span><span class=k>AS</span><span class=w> </span><span class=n>indexes_size</span><span class=p>,</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                </span><span class=n>pg_total_relation_size</span><span class=p>(</span><span class=k>table_name</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>total_size</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>         </span><span class=k>FROM</span><span class=w> </span><span class=p>(</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                  </span><span class=k>SELECT</span><span class=w> </span><span class=p>(</span><span class=s1>&#39;&#34;&#39;</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=n>table_schema</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=s1>&#39;&#34;.&#34;&#39;</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=k>table_name</span><span class=w> </span><span class=o>||</span><span class=w> </span><span class=s1>&#39;&#34;&#39;</span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=k>table_name</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                  </span><span class=k>FROM</span><span class=w> </span><span class=n>information_schema</span><span class=p>.</span><span class=n>tables</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>                  </span><span class=k>where</span><span class=w> </span><span class=n>table_schema</span><span class=w> </span><span class=o>=</span><span class=w> </span><span class=s1>&#39;public&#39;</span><span class=w>  
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>all_tables</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>         </span><span class=k>ORDER</span><span class=w> </span><span class=k>BY</span><span class=w> </span><span class=n>total_size</span><span class=w> </span><span class=k>DESC</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>     </span><span class=p>)</span><span class=w> </span><span class=k>AS</span><span class=w> </span><span class=n>pretty_sizes</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>reindex:</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>REINDEX</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>CONCURRENTLY</span><span class=w> </span><span class=n>history</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div><p>或者手动</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-sql data-lang=sql><span class=line><span class=cl><span class=k>CREATE</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>CONCURRENTLY</span><span class=w> </span><span class=n>history_ts_1</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>history</span><span class=p>(</span><span class=n>ts</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>DROP</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>CONCURRENTLY</span><span class=w> </span><span class=n>history_ts</span><span class=p>;</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>CREATE</span><span class=w> </span><span class=k>UNIQUE</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>CONCURRENTLY</span><span class=w> </span><span class=n>history_pkey_new</span><span class=w> </span><span class=k>ON</span><span class=w> </span><span class=n>history</span><span class=p>(</span><span class=n>uid</span><span class=p>,</span><span class=w> </span><span class=n>vid</span><span class=p>);</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=k>ALTER</span><span class=w> </span><span class=k>TABLE</span><span class=w> </span><span class=n>history</span><span class=w> </span><span class=k>DROP</span><span class=w> </span><span class=k>CONSTRAINT</span><span class=w> </span><span class=n>history_pkey</span><span class=p>,</span><span class=w> </span><span class=k>ADD</span><span class=w> </span><span class=k>CONSTRAINT</span><span class=w> </span><span class=n>history_pkey</span><span class=w> </span><span class=k>PRIMARY</span><span class=w> </span><span class=k>KEY</span><span class=w> </span><span class=k>USING</span><span class=w> </span><span class=k>INDEX</span><span class=w> </span><span class=n>history_pkey_new</span><span class=p>;</span><span class=w>
</span></span></span></code></pre></div></div><footer class=post-footer><ul class=post-tags><li><a href=http://localhost:1313/tags/postgres/>Postgres</a></li><li><a href=http://localhost:1313/tags/%E4%BC%98%E5%8C%96%E5%99%A8/>优化器</a></li><li><a href=http://localhost:1313/tags/%E7%B4%A2%E5%BC%95/>索引</a></li></ul><nav class=paginav><a class=next href=http://localhost:1313/posts/redis/sentinel/><span class=title>下一页 »</span><br><span>redis 哨兵机制</span></a></nav><ul class=share-buttons><li><a target=_blank rel="noopener noreferrer" aria-label="share Postgres 批量删除语句超时 on x" href="https://x.com/intent/tweet/?text=Postgres%20%e6%89%b9%e9%87%8f%e5%88%a0%e9%99%a4%e8%af%ad%e5%8f%a5%e8%b6%85%e6%97%b6&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fpostgres%2fpg_timeout%2f&amp;hashtags=postgres%2c%e4%bc%98%e5%8c%96%e5%99%a8%2c%e7%b4%a2%e5%bc%95"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446C483.971.0 512 28.03 512 62.554zM269.951 190.75 182.567 75.216H56L207.216 272.95 63.9 436.783h61.366L235.9 310.383l96.667 126.4H456L298.367 228.367l134-153.151H371.033zM127.633 110h36.468l219.38 290.065H349.5z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Postgres 批量删除语句超时 on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fpostgres%2fpg_timeout%2f&amp;title=Postgres%20%e6%89%b9%e9%87%8f%e5%88%a0%e9%99%a4%e8%af%ad%e5%8f%a5%e8%b6%85%e6%97%b6&amp;summary=Postgres%20%e6%89%b9%e9%87%8f%e5%88%a0%e9%99%a4%e8%af%ad%e5%8f%a5%e8%b6%85%e6%97%b6&amp;source=http%3a%2f%2flocalhost%3a1313%2fposts%2fpostgres%2fpg_timeout%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Postgres 批量删除语句超时 on reddit" href="https://reddit.com/submit?url=http%3a%2f%2flocalhost%3a1313%2fposts%2fpostgres%2fpg_timeout%2f&title=Postgres%20%e6%89%b9%e9%87%8f%e5%88%a0%e9%99%a4%e8%af%ad%e5%8f%a5%e8%b6%85%e6%97%b6"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Postgres 批量删除语句超时 on facebook" href="https://facebook.com/sharer/sharer.php?u=http%3a%2f%2flocalhost%3a1313%2fposts%2fpostgres%2fpg_timeout%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Postgres 批量删除语句超时 on whatsapp" href="https://api.whatsapp.com/send?text=Postgres%20%e6%89%b9%e9%87%8f%e5%88%a0%e9%99%a4%e8%af%ad%e5%8f%a5%e8%b6%85%e6%97%b6%20-%20http%3a%2f%2flocalhost%3a1313%2fposts%2fpostgres%2fpg_timeout%2f"><svg viewBox="0 0 512 512" height="30" width="30" fill="currentcolor"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Postgres 批量删除语句超时 on telegram" href="https://telegram.me/share/url?text=Postgres%20%e6%89%b9%e9%87%8f%e5%88%a0%e9%99%a4%e8%af%ad%e5%8f%a5%e8%b6%85%e6%97%b6&amp;url=http%3a%2f%2flocalhost%3a1313%2fposts%2fpostgres%2fpg_timeout%2f"><svg viewBox="2 2 28 28" height="30" width="30" fill="currentcolor"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></li><li><a target=_blank rel="noopener noreferrer" aria-label="share Postgres 批量删除语句超时 on ycombinator" href="https://news.ycombinator.com/submitlink?t=Postgres%20%e6%89%b9%e9%87%8f%e5%88%a0%e9%99%a4%e8%af%ad%e5%8f%a5%e8%b6%85%e6%97%b6&u=http%3a%2f%2flocalhost%3a1313%2fposts%2fpostgres%2fpg_timeout%2f"><svg width="30" height="30" viewBox="0 0 512 512" fill="currentcolor" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape"><path d="M449.446.0C483.971.0 512 28.03 512 62.554V449.446C512 483.97 483.97 512 449.446 512H62.554C28.03 512 0 483.97.0 449.446V62.554C0 28.03 28.029.0 62.554.0H449.446zM183.8767 87.9921h-62.034L230.6673 292.4508V424.0079h50.6655V292.4508L390.1575 87.9921H328.1233L256 238.2489z"/></svg></a></li></ul></footer></article></main><footer class=footer><span>&copy; 2024 <a href=http://localhost:1313/>Sweetpear's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script><script>document.querySelectorAll("pre > code").forEach(e=>{const n=e.parentNode.parentNode,t=document.createElement("button");t.classList.add("copy-code"),t.innerHTML="复制";function s(){t.innerHTML="已复制！",setTimeout(()=>{t.innerHTML="复制"},2e3)}t.addEventListener("click",t=>{if("clipboard"in navigator){navigator.clipboard.writeText(e.textContent),s();return}const n=document.createRange();n.selectNodeContents(e);const o=window.getSelection();o.removeAllRanges(),o.addRange(n);try{document.execCommand("copy"),s()}catch{}o.removeRange(n)}),n.classList.contains("highlight")?n.appendChild(t):n.parentNode.firstChild==n||(e.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName=="TABLE"?e.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(t):e.parentNode.appendChild(t))})</script></body></html>